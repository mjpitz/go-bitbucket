// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Issue issue
//
// swagger:model issue
type Issue struct {

	// object additional properties
	ObjectAdditionalProperties map[string]interface{} `json:"-"`

	// assignee
	Assignee *User `json:"assignee,omitempty"`

	// component
	Component *Component `json:"component,omitempty"`

	// content
	Content *IssueAO1Content `json:"content,omitempty"`

	// created on
	// Format: date-time
	CreatedOn strfmt.DateTime `json:"created_on,omitempty"`

	// edited on
	// Format: date-time
	EditedOn strfmt.DateTime `json:"edited_on,omitempty"`

	// id
	ID int64 `json:"id,omitempty"`

	// kind
	// Enum: [bug enhancement proposal task]
	Kind string `json:"kind,omitempty"`

	// links
	Links *IssueAO1Links `json:"links,omitempty"`

	// milestone
	Milestone *Milestone `json:"milestone,omitempty"`

	// priority
	// Enum: [trivial minor major critical blocker]
	Priority string `json:"priority,omitempty"`

	// reporter
	Reporter *User `json:"reporter,omitempty"`

	// repository
	Repository *Repository `json:"repository,omitempty"`

	// state
	// Enum: [new open resolved on hold invalid duplicate wontfix closed]
	State string `json:"state,omitempty"`

	// title
	Title string `json:"title,omitempty"`

	// updated on
	// Format: date-time
	UpdatedOn strfmt.DateTime `json:"updated_on,omitempty"`

	// version
	Version *Version `json:"version,omitempty"`

	// votes
	Votes int64 `json:"votes,omitempty"`

	// a o1 additional properties
	AO1AdditionalProperties map[string]interface{} `json:"-"`
}

// Type gets the type of this subtype
func (m *Issue) Type() string {
	return "issue"
}

// SetType sets the type of this subtype
func (m *Issue) SetType(val string) {
}

// UnmarshalJSON unmarshals this object with a polymorphic type from a JSON structure
func (m *Issue) UnmarshalJSON(raw []byte) error {
	var data struct {

		// assignee
		Assignee *User `json:"assignee,omitempty"`

		// component
		Component *Component `json:"component,omitempty"`

		// content
		Content *IssueAO1Content `json:"content,omitempty"`

		// created on
		// Format: date-time
		CreatedOn strfmt.DateTime `json:"created_on,omitempty"`

		// edited on
		// Format: date-time
		EditedOn strfmt.DateTime `json:"edited_on,omitempty"`

		// id
		ID int64 `json:"id,omitempty"`

		// kind
		// Enum: [bug enhancement proposal task]
		Kind string `json:"kind,omitempty"`

		// links
		Links *IssueAO1Links `json:"links,omitempty"`

		// milestone
		Milestone *Milestone `json:"milestone,omitempty"`

		// priority
		// Enum: [trivial minor major critical blocker]
		Priority string `json:"priority,omitempty"`

		// reporter
		Reporter *User `json:"reporter,omitempty"`

		// repository
		Repository *Repository `json:"repository,omitempty"`

		// state
		// Enum: [new open resolved on hold invalid duplicate wontfix closed]
		State string `json:"state,omitempty"`

		// title
		Title string `json:"title,omitempty"`

		// updated on
		// Format: date-time
		UpdatedOn strfmt.DateTime `json:"updated_on,omitempty"`

		// version
		Version *Version `json:"version,omitempty"`

		// votes
		Votes int64 `json:"votes,omitempty"`

		AO1AdditionalProperties map[string]interface{} `json:"-"`
	}
	buf := bytes.NewBuffer(raw)
	dec := json.NewDecoder(buf)
	dec.UseNumber()

	if err := dec.Decode(&data); err != nil {
		return err
	}

	var base struct {
		/* Just the base type fields. Used for unmashalling polymorphic types.*/

		Type string `json:"type"`
	}
	buf = bytes.NewBuffer(raw)
	dec = json.NewDecoder(buf)
	dec.UseNumber()

	if err := dec.Decode(&base); err != nil {
		return err
	}

	var result Issue

	if base.Type != result.Type() {
		/* Not the type we're looking for. */
		return errors.New(422, "invalid type value: %q", base.Type)
	}

	result.Assignee = data.Assignee
	result.Component = data.Component
	result.Content = data.Content
	result.CreatedOn = data.CreatedOn
	result.EditedOn = data.EditedOn
	result.ID = data.ID
	result.Kind = data.Kind
	result.Links = data.Links
	result.Milestone = data.Milestone
	result.Priority = data.Priority
	result.Reporter = data.Reporter
	result.Repository = data.Repository
	result.State = data.State
	result.Title = data.Title
	result.UpdatedOn = data.UpdatedOn
	result.Version = data.Version
	result.Votes = data.Votes

	*m = result

	return nil
}

// MarshalJSON marshals this object with a polymorphic type to a JSON structure
func (m Issue) MarshalJSON() ([]byte, error) {
	var b1, b2, b3 []byte
	var err error
	b1, err = json.Marshal(struct {

		// assignee
		Assignee *User `json:"assignee,omitempty"`

		// component
		Component *Component `json:"component,omitempty"`

		// content
		Content *IssueAO1Content `json:"content,omitempty"`

		// created on
		// Format: date-time
		CreatedOn strfmt.DateTime `json:"created_on,omitempty"`

		// edited on
		// Format: date-time
		EditedOn strfmt.DateTime `json:"edited_on,omitempty"`

		// id
		ID int64 `json:"id,omitempty"`

		// kind
		// Enum: [bug enhancement proposal task]
		Kind string `json:"kind,omitempty"`

		// links
		Links *IssueAO1Links `json:"links,omitempty"`

		// milestone
		Milestone *Milestone `json:"milestone,omitempty"`

		// priority
		// Enum: [trivial minor major critical blocker]
		Priority string `json:"priority,omitempty"`

		// reporter
		Reporter *User `json:"reporter,omitempty"`

		// repository
		Repository *Repository `json:"repository,omitempty"`

		// state
		// Enum: [new open resolved on hold invalid duplicate wontfix closed]
		State string `json:"state,omitempty"`

		// title
		Title string `json:"title,omitempty"`

		// updated on
		// Format: date-time
		UpdatedOn strfmt.DateTime `json:"updated_on,omitempty"`

		// version
		Version *Version `json:"version,omitempty"`

		// votes
		Votes int64 `json:"votes,omitempty"`

		AO1AdditionalProperties map[string]interface{} `json:"-"`
	}{

		Assignee: m.Assignee,

		Component: m.Component,

		Content: m.Content,

		CreatedOn: m.CreatedOn,

		EditedOn: m.EditedOn,

		ID: m.ID,

		Kind: m.Kind,

		Links: m.Links,

		Milestone: m.Milestone,

		Priority: m.Priority,

		Reporter: m.Reporter,

		Repository: m.Repository,

		State: m.State,

		Title: m.Title,

		UpdatedOn: m.UpdatedOn,

		Version: m.Version,

		Votes: m.Votes,
	})
	if err != nil {
		return nil, err
	}
	b2, err = json.Marshal(struct {
		Type string `json:"type"`
	}{

		Type: m.Type(),
	})
	if err != nil {
		return nil, err
	}

	return swag.ConcatJSON(b1, b2, b3), nil
}

// Validate validates this issue
func (m *Issue) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAssignee(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComponent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedOn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEditedOn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKind(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMilestone(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePriority(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReporter(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRepository(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedOn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Issue) validateAssignee(formats strfmt.Registry) error {

	if swag.IsZero(m.Assignee) { // not required
		return nil
	}

	if m.Assignee != nil {
		if err := m.Assignee.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("assignee")
			}
			return err
		}
	}

	return nil
}

func (m *Issue) validateComponent(formats strfmt.Registry) error {

	if swag.IsZero(m.Component) { // not required
		return nil
	}

	if m.Component != nil {
		if err := m.Component.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("component")
			}
			return err
		}
	}

	return nil
}

func (m *Issue) validateContent(formats strfmt.Registry) error {

	if swag.IsZero(m.Content) { // not required
		return nil
	}

	if m.Content != nil {
		if err := m.Content.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("content")
			}
			return err
		}
	}

	return nil
}

func (m *Issue) validateCreatedOn(formats strfmt.Registry) error {

	if swag.IsZero(m.CreatedOn) { // not required
		return nil
	}

	if err := validate.FormatOf("created_on", "body", "date-time", m.CreatedOn.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Issue) validateEditedOn(formats strfmt.Registry) error {

	if swag.IsZero(m.EditedOn) { // not required
		return nil
	}

	if err := validate.FormatOf("edited_on", "body", "date-time", m.EditedOn.String(), formats); err != nil {
		return err
	}

	return nil
}

var issueTypeKindPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["bug","enhancement","proposal","task"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		issueTypeKindPropEnum = append(issueTypeKindPropEnum, v)
	}
}

// property enum
func (m *Issue) validateKindEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, issueTypeKindPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Issue) validateKind(formats strfmt.Registry) error {

	if swag.IsZero(m.Kind) { // not required
		return nil
	}

	// value enum
	if err := m.validateKindEnum("kind", "body", m.Kind); err != nil {
		return err
	}

	return nil
}

func (m *Issue) validateLinks(formats strfmt.Registry) error {

	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links")
			}
			return err
		}
	}

	return nil
}

func (m *Issue) validateMilestone(formats strfmt.Registry) error {

	if swag.IsZero(m.Milestone) { // not required
		return nil
	}

	if m.Milestone != nil {
		if err := m.Milestone.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("milestone")
			}
			return err
		}
	}

	return nil
}

var issueTypePriorityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["trivial","minor","major","critical","blocker"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		issueTypePriorityPropEnum = append(issueTypePriorityPropEnum, v)
	}
}

// property enum
func (m *Issue) validatePriorityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, issueTypePriorityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Issue) validatePriority(formats strfmt.Registry) error {

	if swag.IsZero(m.Priority) { // not required
		return nil
	}

	// value enum
	if err := m.validatePriorityEnum("priority", "body", m.Priority); err != nil {
		return err
	}

	return nil
}

func (m *Issue) validateReporter(formats strfmt.Registry) error {

	if swag.IsZero(m.Reporter) { // not required
		return nil
	}

	if m.Reporter != nil {
		if err := m.Reporter.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("reporter")
			}
			return err
		}
	}

	return nil
}

func (m *Issue) validateRepository(formats strfmt.Registry) error {

	if swag.IsZero(m.Repository) { // not required
		return nil
	}

	if m.Repository != nil {
		if err := m.Repository.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("repository")
			}
			return err
		}
	}

	return nil
}

var issueTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["new","open","resolved","on hold","invalid","duplicate","wontfix","closed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		issueTypeStatePropEnum = append(issueTypeStatePropEnum, v)
	}
}

// property enum
func (m *Issue) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, issueTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Issue) validateState(formats strfmt.Registry) error {

	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *Issue) validateUpdatedOn(formats strfmt.Registry) error {

	if swag.IsZero(m.UpdatedOn) { // not required
		return nil
	}

	if err := validate.FormatOf("updated_on", "body", "date-time", m.UpdatedOn.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Issue) validateVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if m.Version != nil {
		if err := m.Version.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("version")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Issue) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Issue) UnmarshalBinary(b []byte) error {
	var res Issue
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IssueAO1Content issue a o1 content
//
// swagger:model IssueAO1Content
type IssueAO1Content struct {

	// The user's content rendered as HTML.
	HTML string `json:"html,omitempty"`

	// The type of markup language the raw content is to be interpreted in.
	// Enum: [markdown creole plaintext]
	Markup string `json:"markup,omitempty"`

	// The text as it was typed by a user.
	Raw string `json:"raw,omitempty"`
}

// Validate validates this issue a o1 content
func (m *IssueAO1Content) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMarkup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var issueAO1ContentTypeMarkupPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["markdown","creole","plaintext"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		issueAO1ContentTypeMarkupPropEnum = append(issueAO1ContentTypeMarkupPropEnum, v)
	}
}

const (

	// IssueAO1ContentMarkupMarkdown captures enum value "markdown"
	IssueAO1ContentMarkupMarkdown string = "markdown"

	// IssueAO1ContentMarkupCreole captures enum value "creole"
	IssueAO1ContentMarkupCreole string = "creole"

	// IssueAO1ContentMarkupPlaintext captures enum value "plaintext"
	IssueAO1ContentMarkupPlaintext string = "plaintext"
)

// prop value enum
func (m *IssueAO1Content) validateMarkupEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, issueAO1ContentTypeMarkupPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *IssueAO1Content) validateMarkup(formats strfmt.Registry) error {

	if swag.IsZero(m.Markup) { // not required
		return nil
	}

	// value enum
	if err := m.validateMarkupEnum("content"+"."+"markup", "body", m.Markup); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IssueAO1Content) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IssueAO1Content) UnmarshalBinary(b []byte) error {
	var res IssueAO1Content
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IssueAO1Links issue a o1 links
//
// swagger:model IssueAO1Links
type IssueAO1Links struct {

	// attachments
	Attachments *IssueAO1LinksAttachments `json:"attachments,omitempty"`

	// comments
	Comments *IssueAO1LinksComments `json:"comments,omitempty"`

	// html
	HTML *IssueAO1LinksHTML `json:"html,omitempty"`

	// self
	Self *IssueAO1LinksSelf `json:"self,omitempty"`

	// vote
	Vote *IssueAO1LinksVote `json:"vote,omitempty"`

	// watch
	Watch *IssueAO1LinksWatch `json:"watch,omitempty"`
}

// Validate validates this issue a o1 links
func (m *IssueAO1Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAttachments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHTML(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVote(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWatch(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IssueAO1Links) validateAttachments(formats strfmt.Registry) error {

	if swag.IsZero(m.Attachments) { // not required
		return nil
	}

	if m.Attachments != nil {
		if err := m.Attachments.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links" + "." + "attachments")
			}
			return err
		}
	}

	return nil
}

func (m *IssueAO1Links) validateComments(formats strfmt.Registry) error {

	if swag.IsZero(m.Comments) { // not required
		return nil
	}

	if m.Comments != nil {
		if err := m.Comments.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links" + "." + "comments")
			}
			return err
		}
	}

	return nil
}

func (m *IssueAO1Links) validateHTML(formats strfmt.Registry) error {

	if swag.IsZero(m.HTML) { // not required
		return nil
	}

	if m.HTML != nil {
		if err := m.HTML.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links" + "." + "html")
			}
			return err
		}
	}

	return nil
}

func (m *IssueAO1Links) validateSelf(formats strfmt.Registry) error {

	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (m *IssueAO1Links) validateVote(formats strfmt.Registry) error {

	if swag.IsZero(m.Vote) { // not required
		return nil
	}

	if m.Vote != nil {
		if err := m.Vote.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links" + "." + "vote")
			}
			return err
		}
	}

	return nil
}

func (m *IssueAO1Links) validateWatch(formats strfmt.Registry) error {

	if swag.IsZero(m.Watch) { // not required
		return nil
	}

	if m.Watch != nil {
		if err := m.Watch.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links" + "." + "watch")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IssueAO1Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IssueAO1Links) UnmarshalBinary(b []byte) error {
	var res IssueAO1Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IssueAO1LinksAttachments issue a o1 links attachments
//
// swagger:model IssueAO1LinksAttachments
type IssueAO1LinksAttachments struct {

	// href
	// Format: uri
	Href strfmt.URI `json:"href,omitempty"`

	// name
	Name string `json:"name,omitempty"`
}

// Validate validates this issue a o1 links attachments
func (m *IssueAO1LinksAttachments) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHref(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IssueAO1LinksAttachments) validateHref(formats strfmt.Registry) error {

	if swag.IsZero(m.Href) { // not required
		return nil
	}

	if err := validate.FormatOf("links"+"."+"attachments"+"."+"href", "body", "uri", m.Href.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IssueAO1LinksAttachments) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IssueAO1LinksAttachments) UnmarshalBinary(b []byte) error {
	var res IssueAO1LinksAttachments
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IssueAO1LinksComments issue a o1 links comments
//
// swagger:model IssueAO1LinksComments
type IssueAO1LinksComments struct {

	// href
	// Format: uri
	Href strfmt.URI `json:"href,omitempty"`

	// name
	Name string `json:"name,omitempty"`
}

// Validate validates this issue a o1 links comments
func (m *IssueAO1LinksComments) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHref(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IssueAO1LinksComments) validateHref(formats strfmt.Registry) error {

	if swag.IsZero(m.Href) { // not required
		return nil
	}

	if err := validate.FormatOf("links"+"."+"comments"+"."+"href", "body", "uri", m.Href.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IssueAO1LinksComments) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IssueAO1LinksComments) UnmarshalBinary(b []byte) error {
	var res IssueAO1LinksComments
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IssueAO1LinksHTML issue a o1 links HTML
//
// swagger:model IssueAO1LinksHTML
type IssueAO1LinksHTML struct {

	// href
	// Format: uri
	Href strfmt.URI `json:"href,omitempty"`

	// name
	Name string `json:"name,omitempty"`
}

// Validate validates this issue a o1 links HTML
func (m *IssueAO1LinksHTML) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHref(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IssueAO1LinksHTML) validateHref(formats strfmt.Registry) error {

	if swag.IsZero(m.Href) { // not required
		return nil
	}

	if err := validate.FormatOf("links"+"."+"html"+"."+"href", "body", "uri", m.Href.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IssueAO1LinksHTML) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IssueAO1LinksHTML) UnmarshalBinary(b []byte) error {
	var res IssueAO1LinksHTML
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IssueAO1LinksSelf issue a o1 links self
//
// swagger:model IssueAO1LinksSelf
type IssueAO1LinksSelf struct {

	// href
	// Format: uri
	Href strfmt.URI `json:"href,omitempty"`

	// name
	Name string `json:"name,omitempty"`
}

// Validate validates this issue a o1 links self
func (m *IssueAO1LinksSelf) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHref(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IssueAO1LinksSelf) validateHref(formats strfmt.Registry) error {

	if swag.IsZero(m.Href) { // not required
		return nil
	}

	if err := validate.FormatOf("links"+"."+"self"+"."+"href", "body", "uri", m.Href.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IssueAO1LinksSelf) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IssueAO1LinksSelf) UnmarshalBinary(b []byte) error {
	var res IssueAO1LinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IssueAO1LinksVote issue a o1 links vote
//
// swagger:model IssueAO1LinksVote
type IssueAO1LinksVote struct {

	// href
	// Format: uri
	Href strfmt.URI `json:"href,omitempty"`

	// name
	Name string `json:"name,omitempty"`
}

// Validate validates this issue a o1 links vote
func (m *IssueAO1LinksVote) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHref(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IssueAO1LinksVote) validateHref(formats strfmt.Registry) error {

	if swag.IsZero(m.Href) { // not required
		return nil
	}

	if err := validate.FormatOf("links"+"."+"vote"+"."+"href", "body", "uri", m.Href.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IssueAO1LinksVote) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IssueAO1LinksVote) UnmarshalBinary(b []byte) error {
	var res IssueAO1LinksVote
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IssueAO1LinksWatch issue a o1 links watch
//
// swagger:model IssueAO1LinksWatch
type IssueAO1LinksWatch struct {

	// href
	// Format: uri
	Href strfmt.URI `json:"href,omitempty"`

	// name
	Name string `json:"name,omitempty"`
}

// Validate validates this issue a o1 links watch
func (m *IssueAO1LinksWatch) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHref(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IssueAO1LinksWatch) validateHref(formats strfmt.Registry) error {

	if swag.IsZero(m.Href) { // not required
		return nil
	}

	if err := validate.FormatOf("links"+"."+"watch"+"."+"href", "body", "uri", m.Href.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IssueAO1LinksWatch) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IssueAO1LinksWatch) UnmarshalBinary(b []byte) error {
	var res IssueAO1LinksWatch
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
