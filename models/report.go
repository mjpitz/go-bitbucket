// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Report report
//
// swagger:model report
type Report struct {

	// object additional properties
	ObjectAdditionalProperties map[string]interface{} `json:"-"`

	// The timestamp when the report was created.
	// Format: date-time
	CreatedOn strfmt.DateTime `json:"created_on,omitempty"`

	// An array of data fields to display information on the report. Maximum 10.
	Data []*ReportData `json:"data"`

	// A string to describe the purpose of the report.
	Details string `json:"details,omitempty"`

	// ID of the report provided by the report creator. It can be used to identify the report as an alternative to it's generated uuid. It is not used by Bitbucket, but only by the report creator for updating or deleting this specific report. Needs to be unique.
	ExternalID string `json:"external_id,omitempty"`

	// A URL linking to the results of the report in an external tool.
	// Format: uri
	Link strfmt.URI `json:"link,omitempty"`

	// A URL to the report logo. If none is provided, the default insights logo will be used.
	// Format: uri
	LogoURL strfmt.URI `json:"logo_url,omitempty"`

	// If enabled, a remote link is created in Jira for the issue associated with the commit the report belongs to.
	RemoteLinkEnabled bool `json:"remote_link_enabled,omitempty"`

	// The type of the report.
	// Enum: [SECURITY COVERAGE TEST BUG]
	ReportType string `json:"report_type,omitempty"`

	// A string to describe the tool or company who created the report.
	Reporter string `json:"reporter,omitempty"`

	// The state of the report. May be set to PENDING and later updated.
	// Enum: [PASSED FAILED PENDING]
	Result string `json:"result,omitempty"`

	// The title of the report.
	Title string `json:"title,omitempty"`

	// The timestamp when the report was updated.
	// Format: date-time
	UpdatedOn strfmt.DateTime `json:"updated_on,omitempty"`

	// The UUID that can be used to identify the report.
	UUID string `json:"uuid,omitempty"`

	// a o1 additional properties
	AO1AdditionalProperties map[string]interface{} `json:"-"`
}

// Type gets the type of this subtype
func (m *Report) Type() string {
	return "report"
}

// SetType sets the type of this subtype
func (m *Report) SetType(val string) {
}

// UnmarshalJSON unmarshals this object with a polymorphic type from a JSON structure
func (m *Report) UnmarshalJSON(raw []byte) error {
	var data struct {

		// The timestamp when the report was created.
		// Format: date-time
		CreatedOn strfmt.DateTime `json:"created_on,omitempty"`

		// An array of data fields to display information on the report. Maximum 10.
		Data []*ReportData `json:"data"`

		// A string to describe the purpose of the report.
		Details string `json:"details,omitempty"`

		// ID of the report provided by the report creator. It can be used to identify the report as an alternative to it's generated uuid. It is not used by Bitbucket, but only by the report creator for updating or deleting this specific report. Needs to be unique.
		ExternalID string `json:"external_id,omitempty"`

		// A URL linking to the results of the report in an external tool.
		// Format: uri
		Link strfmt.URI `json:"link,omitempty"`

		// A URL to the report logo. If none is provided, the default insights logo will be used.
		// Format: uri
		LogoURL strfmt.URI `json:"logo_url,omitempty"`

		// If enabled, a remote link is created in Jira for the issue associated with the commit the report belongs to.
		RemoteLinkEnabled bool `json:"remote_link_enabled,omitempty"`

		// The type of the report.
		// Enum: [SECURITY COVERAGE TEST BUG]
		ReportType string `json:"report_type,omitempty"`

		// A string to describe the tool or company who created the report.
		Reporter string `json:"reporter,omitempty"`

		// The state of the report. May be set to PENDING and later updated.
		// Enum: [PASSED FAILED PENDING]
		Result string `json:"result,omitempty"`

		// The title of the report.
		Title string `json:"title,omitempty"`

		// The timestamp when the report was updated.
		// Format: date-time
		UpdatedOn strfmt.DateTime `json:"updated_on,omitempty"`

		// The UUID that can be used to identify the report.
		UUID string `json:"uuid,omitempty"`

		AO1AdditionalProperties map[string]interface{} `json:"-"`
	}
	buf := bytes.NewBuffer(raw)
	dec := json.NewDecoder(buf)
	dec.UseNumber()

	if err := dec.Decode(&data); err != nil {
		return err
	}

	var base struct {
		/* Just the base type fields. Used for unmashalling polymorphic types.*/

		Type string `json:"type"`
	}
	buf = bytes.NewBuffer(raw)
	dec = json.NewDecoder(buf)
	dec.UseNumber()

	if err := dec.Decode(&base); err != nil {
		return err
	}

	var result Report

	if base.Type != result.Type() {
		/* Not the type we're looking for. */
		return errors.New(422, "invalid type value: %q", base.Type)
	}

	result.CreatedOn = data.CreatedOn
	result.Data = data.Data
	result.Details = data.Details
	result.ExternalID = data.ExternalID
	result.Link = data.Link
	result.LogoURL = data.LogoURL
	result.RemoteLinkEnabled = data.RemoteLinkEnabled
	result.ReportType = data.ReportType
	result.Reporter = data.Reporter
	result.Result = data.Result
	result.Title = data.Title
	result.UpdatedOn = data.UpdatedOn
	result.UUID = data.UUID

	*m = result

	return nil
}

// MarshalJSON marshals this object with a polymorphic type to a JSON structure
func (m Report) MarshalJSON() ([]byte, error) {
	var b1, b2, b3 []byte
	var err error
	b1, err = json.Marshal(struct {

		// The timestamp when the report was created.
		// Format: date-time
		CreatedOn strfmt.DateTime `json:"created_on,omitempty"`

		// An array of data fields to display information on the report. Maximum 10.
		Data []*ReportData `json:"data"`

		// A string to describe the purpose of the report.
		Details string `json:"details,omitempty"`

		// ID of the report provided by the report creator. It can be used to identify the report as an alternative to it's generated uuid. It is not used by Bitbucket, but only by the report creator for updating or deleting this specific report. Needs to be unique.
		ExternalID string `json:"external_id,omitempty"`

		// A URL linking to the results of the report in an external tool.
		// Format: uri
		Link strfmt.URI `json:"link,omitempty"`

		// A URL to the report logo. If none is provided, the default insights logo will be used.
		// Format: uri
		LogoURL strfmt.URI `json:"logo_url,omitempty"`

		// If enabled, a remote link is created in Jira for the issue associated with the commit the report belongs to.
		RemoteLinkEnabled bool `json:"remote_link_enabled,omitempty"`

		// The type of the report.
		// Enum: [SECURITY COVERAGE TEST BUG]
		ReportType string `json:"report_type,omitempty"`

		// A string to describe the tool or company who created the report.
		Reporter string `json:"reporter,omitempty"`

		// The state of the report. May be set to PENDING and later updated.
		// Enum: [PASSED FAILED PENDING]
		Result string `json:"result,omitempty"`

		// The title of the report.
		Title string `json:"title,omitempty"`

		// The timestamp when the report was updated.
		// Format: date-time
		UpdatedOn strfmt.DateTime `json:"updated_on,omitempty"`

		// The UUID that can be used to identify the report.
		UUID string `json:"uuid,omitempty"`

		AO1AdditionalProperties map[string]interface{} `json:"-"`
	}{

		CreatedOn: m.CreatedOn,

		Data: m.Data,

		Details: m.Details,

		ExternalID: m.ExternalID,

		Link: m.Link,

		LogoURL: m.LogoURL,

		RemoteLinkEnabled: m.RemoteLinkEnabled,

		ReportType: m.ReportType,

		Reporter: m.Reporter,

		Result: m.Result,

		Title: m.Title,

		UpdatedOn: m.UpdatedOn,

		UUID: m.UUID,
	})
	if err != nil {
		return nil, err
	}
	b2, err = json.Marshal(struct {
		Type string `json:"type"`
	}{

		Type: m.Type(),
	})
	if err != nil {
		return nil, err
	}

	return swag.ConcatJSON(b1, b2, b3), nil
}

// Validate validates this report
func (m *Report) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCreatedOn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLink(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLogoURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReportType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResult(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedOn(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Report) validateCreatedOn(formats strfmt.Registry) error {

	if swag.IsZero(m.CreatedOn) { // not required
		return nil
	}

	if err := validate.FormatOf("created_on", "body", "date-time", m.CreatedOn.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Report) validateData(formats strfmt.Registry) error {

	if swag.IsZero(m.Data) { // not required
		return nil
	}

	for i := 0; i < len(m.Data); i++ {
		if swag.IsZero(m.Data[i]) { // not required
			continue
		}

		if m.Data[i] != nil {
			if err := m.Data[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("data" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Report) validateLink(formats strfmt.Registry) error {

	if swag.IsZero(m.Link) { // not required
		return nil
	}

	if err := validate.FormatOf("link", "body", "uri", m.Link.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Report) validateLogoURL(formats strfmt.Registry) error {

	if swag.IsZero(m.LogoURL) { // not required
		return nil
	}

	if err := validate.FormatOf("logo_url", "body", "uri", m.LogoURL.String(), formats); err != nil {
		return err
	}

	return nil
}

var reportTypeReportTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SECURITY","COVERAGE","TEST","BUG"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		reportTypeReportTypePropEnum = append(reportTypeReportTypePropEnum, v)
	}
}

// property enum
func (m *Report) validateReportTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, reportTypeReportTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Report) validateReportType(formats strfmt.Registry) error {

	if swag.IsZero(m.ReportType) { // not required
		return nil
	}

	// value enum
	if err := m.validateReportTypeEnum("report_type", "body", m.ReportType); err != nil {
		return err
	}

	return nil
}

var reportTypeResultPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PASSED","FAILED","PENDING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		reportTypeResultPropEnum = append(reportTypeResultPropEnum, v)
	}
}

// property enum
func (m *Report) validateResultEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, reportTypeResultPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Report) validateResult(formats strfmt.Registry) error {

	if swag.IsZero(m.Result) { // not required
		return nil
	}

	// value enum
	if err := m.validateResultEnum("result", "body", m.Result); err != nil {
		return err
	}

	return nil
}

func (m *Report) validateUpdatedOn(formats strfmt.Registry) error {

	if swag.IsZero(m.UpdatedOn) { // not required
		return nil
	}

	if err := validate.FormatOf("updated_on", "body", "date-time", m.UpdatedOn.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Report) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Report) UnmarshalBinary(b []byte) error {
	var res Report
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
