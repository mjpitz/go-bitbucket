// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Pullrequest pullrequest
//
// swagger:model pullrequest
type Pullrequest struct {

	// object additional properties
	ObjectAdditionalProperties map[string]interface{} `json:"-"`

	// author
	Author *Account `json:"author,omitempty"`

	// A boolean flag indicating if merging the pull request closes the source branch.
	CloseSourceBranch bool `json:"close_source_branch,omitempty"`

	// closed by
	ClosedBy *Account `json:"closed_by,omitempty"`

	// The number of comments for a specific pull request.
	// Minimum: 0
	CommentCount *int64 `json:"comment_count,omitempty"`

	// The ISO8601 timestamp the request was created.
	// Format: date-time
	CreatedOn strfmt.DateTime `json:"created_on,omitempty"`

	// destination
	Destination *PullrequestEndpoint `json:"destination,omitempty"`

	// The pull request's unique ID. Note that pull request IDs are only unique within their associated repository.
	ID int64 `json:"id,omitempty"`

	// links
	Links *PullrequestAO1Links `json:"links,omitempty"`

	// merge commit
	MergeCommit *PullrequestAO1MergeCommit `json:"merge_commit,omitempty"`

	//         The list of users that are collaborating on this pull request.
	//         Collaborators are user that:
	//
	//         * are added to the pull request as a reviewer (part of the reviewers
	//           list)
	//         * are not explicit reviewers, but have commented on the pull request
	//         * are not explicit reviewers, but have approved the pull request
	//
	//         Each user is wrapped in an object that indicates the user's role and
	//         whether they have approved the pull request. For performance reasons,
	//         the API only returns this list when an API requests a pull request by
	//         id.
	//
	Participants []*Participant `json:"participants"`

	// Explains why a pull request was declined. This field is only applicable to pull requests in rejected state.
	Reason string `json:"reason,omitempty"`

	// rendered
	Rendered *PullrequestAO1Rendered `json:"rendered,omitempty"`

	// The list of users that were added as reviewers on this pull request when it was created. For performance reasons, the API only includes this list on a pull request's `self` URL.
	Reviewers []*Account `json:"reviewers"`

	// source
	Source *PullrequestEndpoint `json:"source,omitempty"`

	// The pull request's current status.
	// Enum: [MERGED SUPERSEDED OPEN DECLINED]
	State string `json:"state,omitempty"`

	// summary
	Summary *PullrequestAO1Summary `json:"summary,omitempty"`

	// The number of open tasks for a specific pull request.
	// Minimum: 0
	TaskCount *int64 `json:"task_count,omitempty"`

	// Title of the pull request.
	Title string `json:"title,omitempty"`

	// The ISO8601 timestamp the request was last updated.
	// Format: date-time
	UpdatedOn strfmt.DateTime `json:"updated_on,omitempty"`

	// a o1 additional properties
	AO1AdditionalProperties map[string]interface{} `json:"-"`
}

// Type gets the type of this subtype
func (m *Pullrequest) Type() string {
	return "pullrequest"
}

// SetType sets the type of this subtype
func (m *Pullrequest) SetType(val string) {
}

// UnmarshalJSON unmarshals this object with a polymorphic type from a JSON structure
func (m *Pullrequest) UnmarshalJSON(raw []byte) error {
	var data struct {

		// author
		Author *Account `json:"author,omitempty"`

		// A boolean flag indicating if merging the pull request closes the source branch.
		CloseSourceBranch bool `json:"close_source_branch,omitempty"`

		// closed by
		ClosedBy *Account `json:"closed_by,omitempty"`

		// The number of comments for a specific pull request.
		// Minimum: 0
		CommentCount *int64 `json:"comment_count,omitempty"`

		// The ISO8601 timestamp the request was created.
		// Format: date-time
		CreatedOn strfmt.DateTime `json:"created_on,omitempty"`

		// destination
		Destination *PullrequestEndpoint `json:"destination,omitempty"`

		// The pull request's unique ID. Note that pull request IDs are only unique within their associated repository.
		ID int64 `json:"id,omitempty"`

		// links
		Links *PullrequestAO1Links `json:"links,omitempty"`

		// merge commit
		MergeCommit *PullrequestAO1MergeCommit `json:"merge_commit,omitempty"`

		//         The list of users that are collaborating on this pull request.
		//         Collaborators are user that:
		//
		//         * are added to the pull request as a reviewer (part of the reviewers
		//           list)
		//         * are not explicit reviewers, but have commented on the pull request
		//         * are not explicit reviewers, but have approved the pull request
		//
		//         Each user is wrapped in an object that indicates the user's role and
		//         whether they have approved the pull request. For performance reasons,
		//         the API only returns this list when an API requests a pull request by
		//         id.
		//
		Participants []*Participant `json:"participants"`

		// Explains why a pull request was declined. This field is only applicable to pull requests in rejected state.
		Reason string `json:"reason,omitempty"`

		// rendered
		Rendered *PullrequestAO1Rendered `json:"rendered,omitempty"`

		// The list of users that were added as reviewers on this pull request when it was created. For performance reasons, the API only includes this list on a pull request's `self` URL.
		Reviewers []*Account `json:"reviewers"`

		// source
		Source *PullrequestEndpoint `json:"source,omitempty"`

		// The pull request's current status.
		// Enum: [MERGED SUPERSEDED OPEN DECLINED]
		State string `json:"state,omitempty"`

		// summary
		Summary *PullrequestAO1Summary `json:"summary,omitempty"`

		// The number of open tasks for a specific pull request.
		// Minimum: 0
		TaskCount *int64 `json:"task_count,omitempty"`

		// Title of the pull request.
		Title string `json:"title,omitempty"`

		// The ISO8601 timestamp the request was last updated.
		// Format: date-time
		UpdatedOn strfmt.DateTime `json:"updated_on,omitempty"`

		AO1AdditionalProperties map[string]interface{} `json:"-"`
	}
	buf := bytes.NewBuffer(raw)
	dec := json.NewDecoder(buf)
	dec.UseNumber()

	if err := dec.Decode(&data); err != nil {
		return err
	}

	var base struct {
		/* Just the base type fields. Used for unmashalling polymorphic types.*/

		Type string `json:"type"`
	}
	buf = bytes.NewBuffer(raw)
	dec = json.NewDecoder(buf)
	dec.UseNumber()

	if err := dec.Decode(&base); err != nil {
		return err
	}

	var result Pullrequest

	if base.Type != result.Type() {
		/* Not the type we're looking for. */
		return errors.New(422, "invalid type value: %q", base.Type)
	}

	result.Author = data.Author
	result.CloseSourceBranch = data.CloseSourceBranch
	result.ClosedBy = data.ClosedBy
	result.CommentCount = data.CommentCount
	result.CreatedOn = data.CreatedOn
	result.Destination = data.Destination
	result.ID = data.ID
	result.Links = data.Links
	result.MergeCommit = data.MergeCommit
	result.Participants = data.Participants
	result.Reason = data.Reason
	result.Rendered = data.Rendered
	result.Reviewers = data.Reviewers
	result.Source = data.Source
	result.State = data.State
	result.Summary = data.Summary
	result.TaskCount = data.TaskCount
	result.Title = data.Title
	result.UpdatedOn = data.UpdatedOn

	*m = result

	return nil
}

// MarshalJSON marshals this object with a polymorphic type to a JSON structure
func (m Pullrequest) MarshalJSON() ([]byte, error) {
	var b1, b2, b3 []byte
	var err error
	b1, err = json.Marshal(struct {

		// author
		Author *Account `json:"author,omitempty"`

		// A boolean flag indicating if merging the pull request closes the source branch.
		CloseSourceBranch bool `json:"close_source_branch,omitempty"`

		// closed by
		ClosedBy *Account `json:"closed_by,omitempty"`

		// The number of comments for a specific pull request.
		// Minimum: 0
		CommentCount *int64 `json:"comment_count,omitempty"`

		// The ISO8601 timestamp the request was created.
		// Format: date-time
		CreatedOn strfmt.DateTime `json:"created_on,omitempty"`

		// destination
		Destination *PullrequestEndpoint `json:"destination,omitempty"`

		// The pull request's unique ID. Note that pull request IDs are only unique within their associated repository.
		ID int64 `json:"id,omitempty"`

		// links
		Links *PullrequestAO1Links `json:"links,omitempty"`

		// merge commit
		MergeCommit *PullrequestAO1MergeCommit `json:"merge_commit,omitempty"`

		//         The list of users that are collaborating on this pull request.
		//         Collaborators are user that:
		//
		//         * are added to the pull request as a reviewer (part of the reviewers
		//           list)
		//         * are not explicit reviewers, but have commented on the pull request
		//         * are not explicit reviewers, but have approved the pull request
		//
		//         Each user is wrapped in an object that indicates the user's role and
		//         whether they have approved the pull request. For performance reasons,
		//         the API only returns this list when an API requests a pull request by
		//         id.
		//
		Participants []*Participant `json:"participants"`

		// Explains why a pull request was declined. This field is only applicable to pull requests in rejected state.
		Reason string `json:"reason,omitempty"`

		// rendered
		Rendered *PullrequestAO1Rendered `json:"rendered,omitempty"`

		// The list of users that were added as reviewers on this pull request when it was created. For performance reasons, the API only includes this list on a pull request's `self` URL.
		Reviewers []*Account `json:"reviewers"`

		// source
		Source *PullrequestEndpoint `json:"source,omitempty"`

		// The pull request's current status.
		// Enum: [MERGED SUPERSEDED OPEN DECLINED]
		State string `json:"state,omitempty"`

		// summary
		Summary *PullrequestAO1Summary `json:"summary,omitempty"`

		// The number of open tasks for a specific pull request.
		// Minimum: 0
		TaskCount *int64 `json:"task_count,omitempty"`

		// Title of the pull request.
		Title string `json:"title,omitempty"`

		// The ISO8601 timestamp the request was last updated.
		// Format: date-time
		UpdatedOn strfmt.DateTime `json:"updated_on,omitempty"`

		AO1AdditionalProperties map[string]interface{} `json:"-"`
	}{

		Author: m.Author,

		CloseSourceBranch: m.CloseSourceBranch,

		ClosedBy: m.ClosedBy,

		CommentCount: m.CommentCount,

		CreatedOn: m.CreatedOn,

		Destination: m.Destination,

		ID: m.ID,

		Links: m.Links,

		MergeCommit: m.MergeCommit,

		Participants: m.Participants,

		Reason: m.Reason,

		Rendered: m.Rendered,

		Reviewers: m.Reviewers,

		Source: m.Source,

		State: m.State,

		Summary: m.Summary,

		TaskCount: m.TaskCount,

		Title: m.Title,

		UpdatedOn: m.UpdatedOn,
	})
	if err != nil {
		return nil, err
	}
	b2, err = json.Marshal(struct {
		Type string `json:"type"`
	}{

		Type: m.Type(),
	})
	if err != nil {
		return nil, err
	}

	return swag.ConcatJSON(b1, b2, b3), nil
}

// Validate validates this pullrequest
func (m *Pullrequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthor(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClosedBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCommentCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedOn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDestination(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMergeCommit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateParticipants(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRendered(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReviewers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSummary(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaskCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedOn(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Pullrequest) validateAuthor(formats strfmt.Registry) error {

	if swag.IsZero(m.Author) { // not required
		return nil
	}

	if m.Author != nil {
		if err := m.Author.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("author")
			}
			return err
		}
	}

	return nil
}

func (m *Pullrequest) validateClosedBy(formats strfmt.Registry) error {

	if swag.IsZero(m.ClosedBy) { // not required
		return nil
	}

	if m.ClosedBy != nil {
		if err := m.ClosedBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("closed_by")
			}
			return err
		}
	}

	return nil
}

func (m *Pullrequest) validateCommentCount(formats strfmt.Registry) error {

	if swag.IsZero(m.CommentCount) { // not required
		return nil
	}

	if err := validate.MinimumInt("comment_count", "body", int64(*m.CommentCount), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *Pullrequest) validateCreatedOn(formats strfmt.Registry) error {

	if swag.IsZero(m.CreatedOn) { // not required
		return nil
	}

	if err := validate.FormatOf("created_on", "body", "date-time", m.CreatedOn.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Pullrequest) validateDestination(formats strfmt.Registry) error {

	if swag.IsZero(m.Destination) { // not required
		return nil
	}

	if m.Destination != nil {
		if err := m.Destination.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destination")
			}
			return err
		}
	}

	return nil
}

func (m *Pullrequest) validateLinks(formats strfmt.Registry) error {

	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links")
			}
			return err
		}
	}

	return nil
}

func (m *Pullrequest) validateMergeCommit(formats strfmt.Registry) error {

	if swag.IsZero(m.MergeCommit) { // not required
		return nil
	}

	if m.MergeCommit != nil {
		if err := m.MergeCommit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("merge_commit")
			}
			return err
		}
	}

	return nil
}

func (m *Pullrequest) validateParticipants(formats strfmt.Registry) error {

	if swag.IsZero(m.Participants) { // not required
		return nil
	}

	for i := 0; i < len(m.Participants); i++ {
		if swag.IsZero(m.Participants[i]) { // not required
			continue
		}

		if m.Participants[i] != nil {
			if err := m.Participants[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("participants" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Pullrequest) validateRendered(formats strfmt.Registry) error {

	if swag.IsZero(m.Rendered) { // not required
		return nil
	}

	if m.Rendered != nil {
		if err := m.Rendered.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rendered")
			}
			return err
		}
	}

	return nil
}

func (m *Pullrequest) validateReviewers(formats strfmt.Registry) error {

	if swag.IsZero(m.Reviewers) { // not required
		return nil
	}

	for i := 0; i < len(m.Reviewers); i++ {
		if swag.IsZero(m.Reviewers[i]) { // not required
			continue
		}

		if m.Reviewers[i] != nil {
			if err := m.Reviewers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("reviewers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Pullrequest) validateSource(formats strfmt.Registry) error {

	if swag.IsZero(m.Source) { // not required
		return nil
	}

	if m.Source != nil {
		if err := m.Source.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("source")
			}
			return err
		}
	}

	return nil
}

var pullrequestTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["MERGED","SUPERSEDED","OPEN","DECLINED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		pullrequestTypeStatePropEnum = append(pullrequestTypeStatePropEnum, v)
	}
}

// property enum
func (m *Pullrequest) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, pullrequestTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Pullrequest) validateState(formats strfmt.Registry) error {

	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *Pullrequest) validateSummary(formats strfmt.Registry) error {

	if swag.IsZero(m.Summary) { // not required
		return nil
	}

	if m.Summary != nil {
		if err := m.Summary.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("summary")
			}
			return err
		}
	}

	return nil
}

func (m *Pullrequest) validateTaskCount(formats strfmt.Registry) error {

	if swag.IsZero(m.TaskCount) { // not required
		return nil
	}

	if err := validate.MinimumInt("task_count", "body", int64(*m.TaskCount), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *Pullrequest) validateUpdatedOn(formats strfmt.Registry) error {

	if swag.IsZero(m.UpdatedOn) { // not required
		return nil
	}

	if err := validate.FormatOf("updated_on", "body", "date-time", m.UpdatedOn.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Pullrequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Pullrequest) UnmarshalBinary(b []byte) error {
	var res Pullrequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PullrequestAO1Links pullrequest a o1 links
//
// swagger:model PullrequestAO1Links
type PullrequestAO1Links struct {

	// activity
	Activity *PullrequestAO1LinksActivity `json:"activity,omitempty"`

	// approve
	Approve *PullrequestAO1LinksApprove `json:"approve,omitempty"`

	// comments
	Comments *PullrequestAO1LinksComments `json:"comments,omitempty"`

	// commits
	Commits *PullrequestAO1LinksCommits `json:"commits,omitempty"`

	// decline
	Decline *PullrequestAO1LinksDecline `json:"decline,omitempty"`

	// diff
	Diff *PullrequestAO1LinksDiff `json:"diff,omitempty"`

	// diffstat
	Diffstat *PullrequestAO1LinksDiffstat `json:"diffstat,omitempty"`

	// html
	HTML *PullrequestAO1LinksHTML `json:"html,omitempty"`

	// merge
	Merge *PullrequestAO1LinksMerge `json:"merge,omitempty"`

	// self
	Self *PullrequestAO1LinksSelf `json:"self,omitempty"`
}

// Validate validates this pullrequest a o1 links
func (m *PullrequestAO1Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateActivity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateApprove(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCommits(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDecline(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDiff(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDiffstat(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHTML(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMerge(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PullrequestAO1Links) validateActivity(formats strfmt.Registry) error {

	if swag.IsZero(m.Activity) { // not required
		return nil
	}

	if m.Activity != nil {
		if err := m.Activity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links" + "." + "activity")
			}
			return err
		}
	}

	return nil
}

func (m *PullrequestAO1Links) validateApprove(formats strfmt.Registry) error {

	if swag.IsZero(m.Approve) { // not required
		return nil
	}

	if m.Approve != nil {
		if err := m.Approve.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links" + "." + "approve")
			}
			return err
		}
	}

	return nil
}

func (m *PullrequestAO1Links) validateComments(formats strfmt.Registry) error {

	if swag.IsZero(m.Comments) { // not required
		return nil
	}

	if m.Comments != nil {
		if err := m.Comments.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links" + "." + "comments")
			}
			return err
		}
	}

	return nil
}

func (m *PullrequestAO1Links) validateCommits(formats strfmt.Registry) error {

	if swag.IsZero(m.Commits) { // not required
		return nil
	}

	if m.Commits != nil {
		if err := m.Commits.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links" + "." + "commits")
			}
			return err
		}
	}

	return nil
}

func (m *PullrequestAO1Links) validateDecline(formats strfmt.Registry) error {

	if swag.IsZero(m.Decline) { // not required
		return nil
	}

	if m.Decline != nil {
		if err := m.Decline.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links" + "." + "decline")
			}
			return err
		}
	}

	return nil
}

func (m *PullrequestAO1Links) validateDiff(formats strfmt.Registry) error {

	if swag.IsZero(m.Diff) { // not required
		return nil
	}

	if m.Diff != nil {
		if err := m.Diff.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links" + "." + "diff")
			}
			return err
		}
	}

	return nil
}

func (m *PullrequestAO1Links) validateDiffstat(formats strfmt.Registry) error {

	if swag.IsZero(m.Diffstat) { // not required
		return nil
	}

	if m.Diffstat != nil {
		if err := m.Diffstat.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links" + "." + "diffstat")
			}
			return err
		}
	}

	return nil
}

func (m *PullrequestAO1Links) validateHTML(formats strfmt.Registry) error {

	if swag.IsZero(m.HTML) { // not required
		return nil
	}

	if m.HTML != nil {
		if err := m.HTML.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links" + "." + "html")
			}
			return err
		}
	}

	return nil
}

func (m *PullrequestAO1Links) validateMerge(formats strfmt.Registry) error {

	if swag.IsZero(m.Merge) { // not required
		return nil
	}

	if m.Merge != nil {
		if err := m.Merge.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links" + "." + "merge")
			}
			return err
		}
	}

	return nil
}

func (m *PullrequestAO1Links) validateSelf(formats strfmt.Registry) error {

	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PullrequestAO1Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PullrequestAO1Links) UnmarshalBinary(b []byte) error {
	var res PullrequestAO1Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PullrequestAO1LinksActivity pullrequest a o1 links activity
//
// swagger:model PullrequestAO1LinksActivity
type PullrequestAO1LinksActivity struct {

	// href
	// Format: uri
	Href strfmt.URI `json:"href,omitempty"`

	// name
	Name string `json:"name,omitempty"`
}

// Validate validates this pullrequest a o1 links activity
func (m *PullrequestAO1LinksActivity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHref(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PullrequestAO1LinksActivity) validateHref(formats strfmt.Registry) error {

	if swag.IsZero(m.Href) { // not required
		return nil
	}

	if err := validate.FormatOf("links"+"."+"activity"+"."+"href", "body", "uri", m.Href.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PullrequestAO1LinksActivity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PullrequestAO1LinksActivity) UnmarshalBinary(b []byte) error {
	var res PullrequestAO1LinksActivity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PullrequestAO1LinksApprove pullrequest a o1 links approve
//
// swagger:model PullrequestAO1LinksApprove
type PullrequestAO1LinksApprove struct {

	// href
	// Format: uri
	Href strfmt.URI `json:"href,omitempty"`

	// name
	Name string `json:"name,omitempty"`
}

// Validate validates this pullrequest a o1 links approve
func (m *PullrequestAO1LinksApprove) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHref(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PullrequestAO1LinksApprove) validateHref(formats strfmt.Registry) error {

	if swag.IsZero(m.Href) { // not required
		return nil
	}

	if err := validate.FormatOf("links"+"."+"approve"+"."+"href", "body", "uri", m.Href.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PullrequestAO1LinksApprove) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PullrequestAO1LinksApprove) UnmarshalBinary(b []byte) error {
	var res PullrequestAO1LinksApprove
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PullrequestAO1LinksComments pullrequest a o1 links comments
//
// swagger:model PullrequestAO1LinksComments
type PullrequestAO1LinksComments struct {

	// href
	// Format: uri
	Href strfmt.URI `json:"href,omitempty"`

	// name
	Name string `json:"name,omitempty"`
}

// Validate validates this pullrequest a o1 links comments
func (m *PullrequestAO1LinksComments) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHref(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PullrequestAO1LinksComments) validateHref(formats strfmt.Registry) error {

	if swag.IsZero(m.Href) { // not required
		return nil
	}

	if err := validate.FormatOf("links"+"."+"comments"+"."+"href", "body", "uri", m.Href.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PullrequestAO1LinksComments) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PullrequestAO1LinksComments) UnmarshalBinary(b []byte) error {
	var res PullrequestAO1LinksComments
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PullrequestAO1LinksCommits pullrequest a o1 links commits
//
// swagger:model PullrequestAO1LinksCommits
type PullrequestAO1LinksCommits struct {

	// href
	// Format: uri
	Href strfmt.URI `json:"href,omitempty"`

	// name
	Name string `json:"name,omitempty"`
}

// Validate validates this pullrequest a o1 links commits
func (m *PullrequestAO1LinksCommits) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHref(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PullrequestAO1LinksCommits) validateHref(formats strfmt.Registry) error {

	if swag.IsZero(m.Href) { // not required
		return nil
	}

	if err := validate.FormatOf("links"+"."+"commits"+"."+"href", "body", "uri", m.Href.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PullrequestAO1LinksCommits) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PullrequestAO1LinksCommits) UnmarshalBinary(b []byte) error {
	var res PullrequestAO1LinksCommits
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PullrequestAO1LinksDecline pullrequest a o1 links decline
//
// swagger:model PullrequestAO1LinksDecline
type PullrequestAO1LinksDecline struct {

	// href
	// Format: uri
	Href strfmt.URI `json:"href,omitempty"`

	// name
	Name string `json:"name,omitempty"`
}

// Validate validates this pullrequest a o1 links decline
func (m *PullrequestAO1LinksDecline) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHref(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PullrequestAO1LinksDecline) validateHref(formats strfmt.Registry) error {

	if swag.IsZero(m.Href) { // not required
		return nil
	}

	if err := validate.FormatOf("links"+"."+"decline"+"."+"href", "body", "uri", m.Href.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PullrequestAO1LinksDecline) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PullrequestAO1LinksDecline) UnmarshalBinary(b []byte) error {
	var res PullrequestAO1LinksDecline
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PullrequestAO1LinksDiff pullrequest a o1 links diff
//
// swagger:model PullrequestAO1LinksDiff
type PullrequestAO1LinksDiff struct {

	// href
	// Format: uri
	Href strfmt.URI `json:"href,omitempty"`

	// name
	Name string `json:"name,omitempty"`
}

// Validate validates this pullrequest a o1 links diff
func (m *PullrequestAO1LinksDiff) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHref(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PullrequestAO1LinksDiff) validateHref(formats strfmt.Registry) error {

	if swag.IsZero(m.Href) { // not required
		return nil
	}

	if err := validate.FormatOf("links"+"."+"diff"+"."+"href", "body", "uri", m.Href.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PullrequestAO1LinksDiff) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PullrequestAO1LinksDiff) UnmarshalBinary(b []byte) error {
	var res PullrequestAO1LinksDiff
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PullrequestAO1LinksDiffstat pullrequest a o1 links diffstat
//
// swagger:model PullrequestAO1LinksDiffstat
type PullrequestAO1LinksDiffstat struct {

	// href
	// Format: uri
	Href strfmt.URI `json:"href,omitempty"`

	// name
	Name string `json:"name,omitempty"`
}

// Validate validates this pullrequest a o1 links diffstat
func (m *PullrequestAO1LinksDiffstat) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHref(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PullrequestAO1LinksDiffstat) validateHref(formats strfmt.Registry) error {

	if swag.IsZero(m.Href) { // not required
		return nil
	}

	if err := validate.FormatOf("links"+"."+"diffstat"+"."+"href", "body", "uri", m.Href.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PullrequestAO1LinksDiffstat) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PullrequestAO1LinksDiffstat) UnmarshalBinary(b []byte) error {
	var res PullrequestAO1LinksDiffstat
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PullrequestAO1LinksHTML pullrequest a o1 links HTML
//
// swagger:model PullrequestAO1LinksHTML
type PullrequestAO1LinksHTML struct {

	// href
	// Format: uri
	Href strfmt.URI `json:"href,omitempty"`

	// name
	Name string `json:"name,omitempty"`
}

// Validate validates this pullrequest a o1 links HTML
func (m *PullrequestAO1LinksHTML) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHref(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PullrequestAO1LinksHTML) validateHref(formats strfmt.Registry) error {

	if swag.IsZero(m.Href) { // not required
		return nil
	}

	if err := validate.FormatOf("links"+"."+"html"+"."+"href", "body", "uri", m.Href.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PullrequestAO1LinksHTML) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PullrequestAO1LinksHTML) UnmarshalBinary(b []byte) error {
	var res PullrequestAO1LinksHTML
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PullrequestAO1LinksMerge pullrequest a o1 links merge
//
// swagger:model PullrequestAO1LinksMerge
type PullrequestAO1LinksMerge struct {

	// href
	// Format: uri
	Href strfmt.URI `json:"href,omitempty"`

	// name
	Name string `json:"name,omitempty"`
}

// Validate validates this pullrequest a o1 links merge
func (m *PullrequestAO1LinksMerge) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHref(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PullrequestAO1LinksMerge) validateHref(formats strfmt.Registry) error {

	if swag.IsZero(m.Href) { // not required
		return nil
	}

	if err := validate.FormatOf("links"+"."+"merge"+"."+"href", "body", "uri", m.Href.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PullrequestAO1LinksMerge) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PullrequestAO1LinksMerge) UnmarshalBinary(b []byte) error {
	var res PullrequestAO1LinksMerge
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PullrequestAO1LinksSelf pullrequest a o1 links self
//
// swagger:model PullrequestAO1LinksSelf
type PullrequestAO1LinksSelf struct {

	// href
	// Format: uri
	Href strfmt.URI `json:"href,omitempty"`

	// name
	Name string `json:"name,omitempty"`
}

// Validate validates this pullrequest a o1 links self
func (m *PullrequestAO1LinksSelf) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHref(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PullrequestAO1LinksSelf) validateHref(formats strfmt.Registry) error {

	if swag.IsZero(m.Href) { // not required
		return nil
	}

	if err := validate.FormatOf("links"+"."+"self"+"."+"href", "body", "uri", m.Href.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PullrequestAO1LinksSelf) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PullrequestAO1LinksSelf) UnmarshalBinary(b []byte) error {
	var res PullrequestAO1LinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PullrequestAO1MergeCommit pullrequest a o1 merge commit
//
// swagger:model PullrequestAO1MergeCommit
type PullrequestAO1MergeCommit struct {

	// hash
	// Pattern: [0-9a-f]{7,}?
	Hash string `json:"hash,omitempty"`
}

// Validate validates this pullrequest a o1 merge commit
func (m *PullrequestAO1MergeCommit) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHash(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PullrequestAO1MergeCommit) validateHash(formats strfmt.Registry) error {

	if swag.IsZero(m.Hash) { // not required
		return nil
	}

	if err := validate.Pattern("merge_commit"+"."+"hash", "body", string(m.Hash), `[0-9a-f]{7,}?`); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PullrequestAO1MergeCommit) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PullrequestAO1MergeCommit) UnmarshalBinary(b []byte) error {
	var res PullrequestAO1MergeCommit
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PullrequestAO1Rendered pullrequest a o1 rendered
//
// swagger:model PullrequestAO1Rendered
type PullrequestAO1Rendered struct {

	// description
	Description *PullrequestAO1RenderedDescription `json:"description,omitempty"`

	// reason
	Reason *PullrequestAO1RenderedReason `json:"reason,omitempty"`

	// title
	Title *PullrequestAO1RenderedTitle `json:"title,omitempty"`
}

// Validate validates this pullrequest a o1 rendered
func (m *PullrequestAO1Rendered) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReason(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTitle(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PullrequestAO1Rendered) validateDescription(formats strfmt.Registry) error {

	if swag.IsZero(m.Description) { // not required
		return nil
	}

	if m.Description != nil {
		if err := m.Description.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rendered" + "." + "description")
			}
			return err
		}
	}

	return nil
}

func (m *PullrequestAO1Rendered) validateReason(formats strfmt.Registry) error {

	if swag.IsZero(m.Reason) { // not required
		return nil
	}

	if m.Reason != nil {
		if err := m.Reason.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rendered" + "." + "reason")
			}
			return err
		}
	}

	return nil
}

func (m *PullrequestAO1Rendered) validateTitle(formats strfmt.Registry) error {

	if swag.IsZero(m.Title) { // not required
		return nil
	}

	if m.Title != nil {
		if err := m.Title.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rendered" + "." + "title")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PullrequestAO1Rendered) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PullrequestAO1Rendered) UnmarshalBinary(b []byte) error {
	var res PullrequestAO1Rendered
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PullrequestAO1RenderedDescription pullrequest a o1 rendered description
//
// swagger:model PullrequestAO1RenderedDescription
type PullrequestAO1RenderedDescription struct {

	// The user's content rendered as HTML.
	HTML string `json:"html,omitempty"`

	// The type of markup language the raw content is to be interpreted in.
	// Enum: [markdown creole plaintext]
	Markup string `json:"markup,omitempty"`

	// The text as it was typed by a user.
	Raw string `json:"raw,omitempty"`
}

// Validate validates this pullrequest a o1 rendered description
func (m *PullrequestAO1RenderedDescription) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMarkup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var pullrequestAO1RenderedDescriptionTypeMarkupPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["markdown","creole","plaintext"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		pullrequestAO1RenderedDescriptionTypeMarkupPropEnum = append(pullrequestAO1RenderedDescriptionTypeMarkupPropEnum, v)
	}
}

const (

	// PullrequestAO1RenderedDescriptionMarkupMarkdown captures enum value "markdown"
	PullrequestAO1RenderedDescriptionMarkupMarkdown string = "markdown"

	// PullrequestAO1RenderedDescriptionMarkupCreole captures enum value "creole"
	PullrequestAO1RenderedDescriptionMarkupCreole string = "creole"

	// PullrequestAO1RenderedDescriptionMarkupPlaintext captures enum value "plaintext"
	PullrequestAO1RenderedDescriptionMarkupPlaintext string = "plaintext"
)

// prop value enum
func (m *PullrequestAO1RenderedDescription) validateMarkupEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, pullrequestAO1RenderedDescriptionTypeMarkupPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PullrequestAO1RenderedDescription) validateMarkup(formats strfmt.Registry) error {

	if swag.IsZero(m.Markup) { // not required
		return nil
	}

	// value enum
	if err := m.validateMarkupEnum("rendered"+"."+"description"+"."+"markup", "body", m.Markup); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PullrequestAO1RenderedDescription) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PullrequestAO1RenderedDescription) UnmarshalBinary(b []byte) error {
	var res PullrequestAO1RenderedDescription
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PullrequestAO1RenderedReason pullrequest a o1 rendered reason
//
// swagger:model PullrequestAO1RenderedReason
type PullrequestAO1RenderedReason struct {

	// The user's content rendered as HTML.
	HTML string `json:"html,omitempty"`

	// The type of markup language the raw content is to be interpreted in.
	// Enum: [markdown creole plaintext]
	Markup string `json:"markup,omitempty"`

	// The text as it was typed by a user.
	Raw string `json:"raw,omitempty"`
}

// Validate validates this pullrequest a o1 rendered reason
func (m *PullrequestAO1RenderedReason) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMarkup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var pullrequestAO1RenderedReasonTypeMarkupPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["markdown","creole","plaintext"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		pullrequestAO1RenderedReasonTypeMarkupPropEnum = append(pullrequestAO1RenderedReasonTypeMarkupPropEnum, v)
	}
}

const (

	// PullrequestAO1RenderedReasonMarkupMarkdown captures enum value "markdown"
	PullrequestAO1RenderedReasonMarkupMarkdown string = "markdown"

	// PullrequestAO1RenderedReasonMarkupCreole captures enum value "creole"
	PullrequestAO1RenderedReasonMarkupCreole string = "creole"

	// PullrequestAO1RenderedReasonMarkupPlaintext captures enum value "plaintext"
	PullrequestAO1RenderedReasonMarkupPlaintext string = "plaintext"
)

// prop value enum
func (m *PullrequestAO1RenderedReason) validateMarkupEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, pullrequestAO1RenderedReasonTypeMarkupPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PullrequestAO1RenderedReason) validateMarkup(formats strfmt.Registry) error {

	if swag.IsZero(m.Markup) { // not required
		return nil
	}

	// value enum
	if err := m.validateMarkupEnum("rendered"+"."+"reason"+"."+"markup", "body", m.Markup); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PullrequestAO1RenderedReason) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PullrequestAO1RenderedReason) UnmarshalBinary(b []byte) error {
	var res PullrequestAO1RenderedReason
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PullrequestAO1RenderedTitle pullrequest a o1 rendered title
//
// swagger:model PullrequestAO1RenderedTitle
type PullrequestAO1RenderedTitle struct {

	// The user's content rendered as HTML.
	HTML string `json:"html,omitempty"`

	// The type of markup language the raw content is to be interpreted in.
	// Enum: [markdown creole plaintext]
	Markup string `json:"markup,omitempty"`

	// The text as it was typed by a user.
	Raw string `json:"raw,omitempty"`
}

// Validate validates this pullrequest a o1 rendered title
func (m *PullrequestAO1RenderedTitle) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMarkup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var pullrequestAO1RenderedTitleTypeMarkupPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["markdown","creole","plaintext"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		pullrequestAO1RenderedTitleTypeMarkupPropEnum = append(pullrequestAO1RenderedTitleTypeMarkupPropEnum, v)
	}
}

const (

	// PullrequestAO1RenderedTitleMarkupMarkdown captures enum value "markdown"
	PullrequestAO1RenderedTitleMarkupMarkdown string = "markdown"

	// PullrequestAO1RenderedTitleMarkupCreole captures enum value "creole"
	PullrequestAO1RenderedTitleMarkupCreole string = "creole"

	// PullrequestAO1RenderedTitleMarkupPlaintext captures enum value "plaintext"
	PullrequestAO1RenderedTitleMarkupPlaintext string = "plaintext"
)

// prop value enum
func (m *PullrequestAO1RenderedTitle) validateMarkupEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, pullrequestAO1RenderedTitleTypeMarkupPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PullrequestAO1RenderedTitle) validateMarkup(formats strfmt.Registry) error {

	if swag.IsZero(m.Markup) { // not required
		return nil
	}

	// value enum
	if err := m.validateMarkupEnum("rendered"+"."+"title"+"."+"markup", "body", m.Markup); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PullrequestAO1RenderedTitle) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PullrequestAO1RenderedTitle) UnmarshalBinary(b []byte) error {
	var res PullrequestAO1RenderedTitle
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PullrequestAO1Summary pullrequest a o1 summary
//
// swagger:model PullrequestAO1Summary
type PullrequestAO1Summary struct {

	// The user's content rendered as HTML.
	HTML string `json:"html,omitempty"`

	// The type of markup language the raw content is to be interpreted in.
	// Enum: [markdown creole plaintext]
	Markup string `json:"markup,omitempty"`

	// The text as it was typed by a user.
	Raw string `json:"raw,omitempty"`
}

// Validate validates this pullrequest a o1 summary
func (m *PullrequestAO1Summary) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMarkup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var pullrequestAO1SummaryTypeMarkupPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["markdown","creole","plaintext"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		pullrequestAO1SummaryTypeMarkupPropEnum = append(pullrequestAO1SummaryTypeMarkupPropEnum, v)
	}
}

const (

	// PullrequestAO1SummaryMarkupMarkdown captures enum value "markdown"
	PullrequestAO1SummaryMarkupMarkdown string = "markdown"

	// PullrequestAO1SummaryMarkupCreole captures enum value "creole"
	PullrequestAO1SummaryMarkupCreole string = "creole"

	// PullrequestAO1SummaryMarkupPlaintext captures enum value "plaintext"
	PullrequestAO1SummaryMarkupPlaintext string = "plaintext"
)

// prop value enum
func (m *PullrequestAO1Summary) validateMarkupEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, pullrequestAO1SummaryTypeMarkupPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PullrequestAO1Summary) validateMarkup(formats strfmt.Registry) error {

	if swag.IsZero(m.Markup) { // not required
		return nil
	}

	// value enum
	if err := m.validateMarkupEnum("summary"+"."+"markup", "body", m.Markup); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PullrequestAO1Summary) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PullrequestAO1Summary) UnmarshalBinary(b []byte) error {
	var res PullrequestAO1Summary
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
