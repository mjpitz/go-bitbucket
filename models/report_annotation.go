// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ReportAnnotation report annotation
//
// swagger:model report_annotation
type ReportAnnotation struct {

	// object additional properties
	ObjectAdditionalProperties map[string]interface{} `json:"-"`

	// The type of the report.
	// Enum: [VULNERABILITY CODE_SMELL BUG]
	AnnotationType string `json:"annotation_type,omitempty"`

	// The timestamp when the report was created.
	// Format: date-time
	CreatedOn strfmt.DateTime `json:"created_on,omitempty"`

	// The details to show to users when clicking on the annotation.
	Details string `json:"details,omitempty"`

	// ID of the annotation provided by the annotation creator. It can be used to identify the annotation as an alternative to it's generated uuid. It is not used by Bitbucket, but only by the annotation creator for updating or deleting this specific annotation. Needs to be unique.
	ExternalID string `json:"external_id,omitempty"`

	// The line number that the annotation should belong to. If no line number is provided, then it will default to 0 and in a pull request it will appear at the top of the file specified by the path field.
	// Minimum: 1
	Line int64 `json:"line,omitempty"`

	// A URL linking to the annotation in an external tool.
	// Format: uri
	Link strfmt.URI `json:"link,omitempty"`

	// The path of the file on which this annotation should be placed. This is the path of the file relative to the git repository. If no path is provided, then it will appear in the overview modal on all pull requests where the tip of the branch is the given commit, regardless of which files were modified.
	Path string `json:"path,omitempty"`

	// The state of the report. May be set to PENDING and later updated.
	// Enum: [PASSED FAILED SKIPPED IGNORED]
	Result string `json:"result,omitempty"`

	// The severity of the annotation.
	// Enum: [CRITICAL HIGH MEDIUM LOW]
	Severity string `json:"severity,omitempty"`

	// The message to display to users.
	Summary string `json:"summary,omitempty"`

	// The timestamp when the report was updated.
	// Format: date-time
	UpdatedOn strfmt.DateTime `json:"updated_on,omitempty"`

	// The UUID that can be used to identify the annotation.
	UUID string `json:"uuid,omitempty"`

	// a o1 additional properties
	AO1AdditionalProperties map[string]interface{} `json:"-"`
}

// Type gets the type of this subtype
func (m *ReportAnnotation) Type() string {
	return "report_annotation"
}

// SetType sets the type of this subtype
func (m *ReportAnnotation) SetType(val string) {
}

// UnmarshalJSON unmarshals this object with a polymorphic type from a JSON structure
func (m *ReportAnnotation) UnmarshalJSON(raw []byte) error {
	var data struct {

		// The type of the report.
		// Enum: [VULNERABILITY CODE_SMELL BUG]
		AnnotationType string `json:"annotation_type,omitempty"`

		// The timestamp when the report was created.
		// Format: date-time
		CreatedOn strfmt.DateTime `json:"created_on,omitempty"`

		// The details to show to users when clicking on the annotation.
		Details string `json:"details,omitempty"`

		// ID of the annotation provided by the annotation creator. It can be used to identify the annotation as an alternative to it's generated uuid. It is not used by Bitbucket, but only by the annotation creator for updating or deleting this specific annotation. Needs to be unique.
		ExternalID string `json:"external_id,omitempty"`

		// The line number that the annotation should belong to. If no line number is provided, then it will default to 0 and in a pull request it will appear at the top of the file specified by the path field.
		// Minimum: 1
		Line int64 `json:"line,omitempty"`

		// A URL linking to the annotation in an external tool.
		// Format: uri
		Link strfmt.URI `json:"link,omitempty"`

		// The path of the file on which this annotation should be placed. This is the path of the file relative to the git repository. If no path is provided, then it will appear in the overview modal on all pull requests where the tip of the branch is the given commit, regardless of which files were modified.
		Path string `json:"path,omitempty"`

		// The state of the report. May be set to PENDING and later updated.
		// Enum: [PASSED FAILED SKIPPED IGNORED]
		Result string `json:"result,omitempty"`

		// The severity of the annotation.
		// Enum: [CRITICAL HIGH MEDIUM LOW]
		Severity string `json:"severity,omitempty"`

		// The message to display to users.
		Summary string `json:"summary,omitempty"`

		// The timestamp when the report was updated.
		// Format: date-time
		UpdatedOn strfmt.DateTime `json:"updated_on,omitempty"`

		// The UUID that can be used to identify the annotation.
		UUID string `json:"uuid,omitempty"`

		AO1AdditionalProperties map[string]interface{} `json:"-"`
	}
	buf := bytes.NewBuffer(raw)
	dec := json.NewDecoder(buf)
	dec.UseNumber()

	if err := dec.Decode(&data); err != nil {
		return err
	}

	var base struct {
		/* Just the base type fields. Used for unmashalling polymorphic types.*/

		Type string `json:"type"`
	}
	buf = bytes.NewBuffer(raw)
	dec = json.NewDecoder(buf)
	dec.UseNumber()

	if err := dec.Decode(&base); err != nil {
		return err
	}

	var result ReportAnnotation

	if base.Type != result.Type() {
		/* Not the type we're looking for. */
		return errors.New(422, "invalid type value: %q", base.Type)
	}

	result.AnnotationType = data.AnnotationType
	result.CreatedOn = data.CreatedOn
	result.Details = data.Details
	result.ExternalID = data.ExternalID
	result.Line = data.Line
	result.Link = data.Link
	result.Path = data.Path
	result.Result = data.Result
	result.Severity = data.Severity
	result.Summary = data.Summary
	result.UpdatedOn = data.UpdatedOn
	result.UUID = data.UUID

	*m = result

	return nil
}

// MarshalJSON marshals this object with a polymorphic type to a JSON structure
func (m ReportAnnotation) MarshalJSON() ([]byte, error) {
	var b1, b2, b3 []byte
	var err error
	b1, err = json.Marshal(struct {

		// The type of the report.
		// Enum: [VULNERABILITY CODE_SMELL BUG]
		AnnotationType string `json:"annotation_type,omitempty"`

		// The timestamp when the report was created.
		// Format: date-time
		CreatedOn strfmt.DateTime `json:"created_on,omitempty"`

		// The details to show to users when clicking on the annotation.
		Details string `json:"details,omitempty"`

		// ID of the annotation provided by the annotation creator. It can be used to identify the annotation as an alternative to it's generated uuid. It is not used by Bitbucket, but only by the annotation creator for updating or deleting this specific annotation. Needs to be unique.
		ExternalID string `json:"external_id,omitempty"`

		// The line number that the annotation should belong to. If no line number is provided, then it will default to 0 and in a pull request it will appear at the top of the file specified by the path field.
		// Minimum: 1
		Line int64 `json:"line,omitempty"`

		// A URL linking to the annotation in an external tool.
		// Format: uri
		Link strfmt.URI `json:"link,omitempty"`

		// The path of the file on which this annotation should be placed. This is the path of the file relative to the git repository. If no path is provided, then it will appear in the overview modal on all pull requests where the tip of the branch is the given commit, regardless of which files were modified.
		Path string `json:"path,omitempty"`

		// The state of the report. May be set to PENDING and later updated.
		// Enum: [PASSED FAILED SKIPPED IGNORED]
		Result string `json:"result,omitempty"`

		// The severity of the annotation.
		// Enum: [CRITICAL HIGH MEDIUM LOW]
		Severity string `json:"severity,omitempty"`

		// The message to display to users.
		Summary string `json:"summary,omitempty"`

		// The timestamp when the report was updated.
		// Format: date-time
		UpdatedOn strfmt.DateTime `json:"updated_on,omitempty"`

		// The UUID that can be used to identify the annotation.
		UUID string `json:"uuid,omitempty"`

		AO1AdditionalProperties map[string]interface{} `json:"-"`
	}{

		AnnotationType: m.AnnotationType,

		CreatedOn: m.CreatedOn,

		Details: m.Details,

		ExternalID: m.ExternalID,

		Line: m.Line,

		Link: m.Link,

		Path: m.Path,

		Result: m.Result,

		Severity: m.Severity,

		Summary: m.Summary,

		UpdatedOn: m.UpdatedOn,

		UUID: m.UUID,
	})
	if err != nil {
		return nil, err
	}
	b2, err = json.Marshal(struct {
		Type string `json:"type"`
	}{

		Type: m.Type(),
	})
	if err != nil {
		return nil, err
	}

	return swag.ConcatJSON(b1, b2, b3), nil
}

// Validate validates this report annotation
func (m *ReportAnnotation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAnnotationType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedOn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLine(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLink(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResult(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSeverity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedOn(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var reportAnnotationTypeAnnotationTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["VULNERABILITY","CODE_SMELL","BUG"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		reportAnnotationTypeAnnotationTypePropEnum = append(reportAnnotationTypeAnnotationTypePropEnum, v)
	}
}

// property enum
func (m *ReportAnnotation) validateAnnotationTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, reportAnnotationTypeAnnotationTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ReportAnnotation) validateAnnotationType(formats strfmt.Registry) error {

	if swag.IsZero(m.AnnotationType) { // not required
		return nil
	}

	// value enum
	if err := m.validateAnnotationTypeEnum("annotation_type", "body", m.AnnotationType); err != nil {
		return err
	}

	return nil
}

func (m *ReportAnnotation) validateCreatedOn(formats strfmt.Registry) error {

	if swag.IsZero(m.CreatedOn) { // not required
		return nil
	}

	if err := validate.FormatOf("created_on", "body", "date-time", m.CreatedOn.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ReportAnnotation) validateLine(formats strfmt.Registry) error {

	if swag.IsZero(m.Line) { // not required
		return nil
	}

	if err := validate.MinimumInt("line", "body", int64(m.Line), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *ReportAnnotation) validateLink(formats strfmt.Registry) error {

	if swag.IsZero(m.Link) { // not required
		return nil
	}

	if err := validate.FormatOf("link", "body", "uri", m.Link.String(), formats); err != nil {
		return err
	}

	return nil
}

var reportAnnotationTypeResultPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PASSED","FAILED","SKIPPED","IGNORED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		reportAnnotationTypeResultPropEnum = append(reportAnnotationTypeResultPropEnum, v)
	}
}

// property enum
func (m *ReportAnnotation) validateResultEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, reportAnnotationTypeResultPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ReportAnnotation) validateResult(formats strfmt.Registry) error {

	if swag.IsZero(m.Result) { // not required
		return nil
	}

	// value enum
	if err := m.validateResultEnum("result", "body", m.Result); err != nil {
		return err
	}

	return nil
}

var reportAnnotationTypeSeverityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CRITICAL","HIGH","MEDIUM","LOW"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		reportAnnotationTypeSeverityPropEnum = append(reportAnnotationTypeSeverityPropEnum, v)
	}
}

// property enum
func (m *ReportAnnotation) validateSeverityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, reportAnnotationTypeSeverityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ReportAnnotation) validateSeverity(formats strfmt.Registry) error {

	if swag.IsZero(m.Severity) { // not required
		return nil
	}

	// value enum
	if err := m.validateSeverityEnum("severity", "body", m.Severity); err != nil {
		return err
	}

	return nil
}

func (m *ReportAnnotation) validateUpdatedOn(formats strfmt.Registry) error {

	if swag.IsZero(m.UpdatedOn) { // not required
		return nil
	}

	if err := validate.FormatOf("updated_on", "body", "date-time", m.UpdatedOn.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ReportAnnotation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ReportAnnotation) UnmarshalBinary(b []byte) error {
	var res ReportAnnotation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
