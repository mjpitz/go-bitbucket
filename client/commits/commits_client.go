// Code generated by go-swagger; DO NOT EDIT.

package commits

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new commits API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for commits API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientService is the interface for Client methods
type ClientService interface {
	DeleteRepositoriesWorkspaceRepoSlugCommitNodeApprove(params *DeleteRepositoriesWorkspaceRepoSlugCommitNodeApproveParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteRepositoriesWorkspaceRepoSlugCommitNodeApproveNoContent, error)

	GetRepositoriesWorkspaceRepoSlugCommitNode(params *GetRepositoriesWorkspaceRepoSlugCommitNodeParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesWorkspaceRepoSlugCommitNodeOK, error)

	GetRepositoriesWorkspaceRepoSlugCommitNodeComments(params *GetRepositoriesWorkspaceRepoSlugCommitNodeCommentsParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesWorkspaceRepoSlugCommitNodeCommentsOK, error)

	GetRepositoriesWorkspaceRepoSlugCommitNodeCommentsCommentID(params *GetRepositoriesWorkspaceRepoSlugCommitNodeCommentsCommentIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesWorkspaceRepoSlugCommitNodeCommentsCommentIDOK, error)

	GetRepositoriesWorkspaceRepoSlugCommits(params *GetRepositoriesWorkspaceRepoSlugCommitsParams, authInfo runtime.ClientAuthInfoWriter) error

	GetRepositoriesWorkspaceRepoSlugCommitsRevision(params *GetRepositoriesWorkspaceRepoSlugCommitsRevisionParams, authInfo runtime.ClientAuthInfoWriter) error

	GetRepositoriesWorkspaceRepoSlugDiffSpec(params *GetRepositoriesWorkspaceRepoSlugDiffSpecParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesWorkspaceRepoSlugDiffSpecOK, error)

	GetRepositoriesWorkspaceRepoSlugMergeBaseRevspec(params *GetRepositoriesWorkspaceRepoSlugMergeBaseRevspecParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesWorkspaceRepoSlugMergeBaseRevspecOK, error)

	GetRepositoriesWorkspaceRepoSlugPatchSpec(params *GetRepositoriesWorkspaceRepoSlugPatchSpecParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesWorkspaceRepoSlugPatchSpecOK, error)

	PostRepositoriesWorkspaceRepoSlugCommitNodeApprove(params *PostRepositoriesWorkspaceRepoSlugCommitNodeApproveParams, authInfo runtime.ClientAuthInfoWriter) (*PostRepositoriesWorkspaceRepoSlugCommitNodeApproveOK, error)

	PostRepositoriesWorkspaceRepoSlugCommitNodeComments(params *PostRepositoriesWorkspaceRepoSlugCommitNodeCommentsParams, authInfo runtime.ClientAuthInfoWriter) (*PostRepositoriesWorkspaceRepoSlugCommitNodeCommentsCreated, error)

	PostRepositoriesWorkspaceRepoSlugCommits(params *PostRepositoriesWorkspaceRepoSlugCommitsParams, authInfo runtime.ClientAuthInfoWriter) error

	PostRepositoriesWorkspaceRepoSlugCommitsRevision(params *PostRepositoriesWorkspaceRepoSlugCommitsRevisionParams, authInfo runtime.ClientAuthInfoWriter) error

	SetTransport(transport runtime.ClientTransport)
}

/*
  DeleteRepositoriesWorkspaceRepoSlugCommitNodeApprove Redact the authenticated user's approval of the specified commit.

This operation is only available to users that have explicit access to
the repository. In contrast, just the fact that a repository is
publicly accessible to users does not give them the ability to approve
commits.
*/
func (a *Client) DeleteRepositoriesWorkspaceRepoSlugCommitNodeApprove(params *DeleteRepositoriesWorkspaceRepoSlugCommitNodeApproveParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteRepositoriesWorkspaceRepoSlugCommitNodeApproveNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRepositoriesWorkspaceRepoSlugCommitNodeApproveParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteRepositoriesWorkspaceRepoSlugCommitNodeApprove",
		Method:             "DELETE",
		PathPattern:        "/repositories/{workspace}/{repo_slug}/commit/{node}/approve",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteRepositoriesWorkspaceRepoSlugCommitNodeApproveReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteRepositoriesWorkspaceRepoSlugCommitNodeApproveNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for DeleteRepositoriesWorkspaceRepoSlugCommitNodeApprove: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetRepositoriesWorkspaceRepoSlugCommitNode Returns the specified commit.

Example:

```
$ curl https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a1
{
    "rendered": {
        "message": {
        "raw": "Add a GEORDI_OUTPUT_DIR setting",
        "markup": "markdown",
        "html": "<p>Add a GEORDI_OUTPUT_DIR setting</p>",
        "type": "rendered"
        }
    },
    "hash": "f7591a13eda445d9a9167f98eb870319f4b6c2d8",
    "repository": {
        "name": "geordi",
        "type": "repository",
        "full_name": "bitbucket/geordi",
        "links": {
            "self": {
                "href": "https://api.bitbucket.org/2.0/repositories/bitbucket/geordi"
            },
            "html": {
                "href": "https://bitbucket.org/bitbucket/geordi"
            },
            "avatar": {
                "href": "https://bytebucket.org/ravatar/%7B85d08b4e-571d-44e9-a507-fa476535aa98%7D?ts=1730260"
            }
        },
        "uuid": "{85d08b4e-571d-44e9-a507-fa476535aa98}"
    },
    "links": {
        "self": {
            "href": "https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8"
        },
        "comments": {
            "href": "https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/comments"
        },
        "patch": {
            "href": "https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/patch/f7591a13eda445d9a9167f98eb870319f4b6c2d8"
        },
        "html": {
            "href": "https://bitbucket.org/bitbucket/geordi/commits/f7591a13eda445d9a9167f98eb870319f4b6c2d8"
        },
        "diff": {
            "href": "https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/diff/f7591a13eda445d9a9167f98eb870319f4b6c2d8"
        },
        "approve": {
            "href": "https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/approve"
        },
        "statuses": {
            "href": "https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/statuses"
        }
    },
    "author": {
        "raw": "Brodie Rao <a@b.c>",
        "type": "author",
        "user": {
            "display_name": "Brodie Rao",
            "uuid": "{9484702e-c663-4afd-aefb-c93a8cd31c28}",
            "links": {
                "self": {
                    "href": "https://api.bitbucket.org/2.0/users/%7B9484702e-c663-4afd-aefb-c93a8cd31c28%7D"
                },
                "html": {
                    "href": "https://bitbucket.org/%7B9484702e-c663-4afd-aefb-c93a8cd31c28%7D/"
                },
                "avatar": {
                    "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:3aae1e05-702a-41e5-81c8-f36f29afb6ca/613070db-28b0-421f-8dba-ae8a87e2a5c7/128"
                }
            },
            "type": "user",
            "nickname": "brodie",
            "account_id": "557058:3aae1e05-702a-41e5-81c8-f36f29afb6ca"
        }
    },
    "summary": {
        "raw": "Add a GEORDI_OUTPUT_DIR setting",
        "markup": "markdown",
        "html": "<p>Add a GEORDI_OUTPUT_DIR setting</p>",
        "type": "rendered"
    },
    "participants": [],
    "parents": [
        {
            "type": "commit",
            "hash": "f06941fec4ef6bcb0c2456927a0cf258fa4f899b",
            "links": {
                "self": {
                    "href": "https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f06941fec4ef6bcb0c2456927a0cf258fa4f899b"
                },
                "html": {
                    "href": "https://bitbucket.org/bitbucket/geordi/commits/f06941fec4ef6bcb0c2456927a0cf258fa4f899b"
                }
            }
        }
    ],
    "date": "2012-07-16T19:37:54+00:00",
    "message": "Add a GEORDI_OUTPUT_DIR setting",
    "type": "commit"
}
```
*/
func (a *Client) GetRepositoriesWorkspaceRepoSlugCommitNode(params *GetRepositoriesWorkspaceRepoSlugCommitNodeParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesWorkspaceRepoSlugCommitNodeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepositoriesWorkspaceRepoSlugCommitNodeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRepositoriesWorkspaceRepoSlugCommitNode",
		Method:             "GET",
		PathPattern:        "/repositories/{workspace}/{repo_slug}/commit/{node}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRepositoriesWorkspaceRepoSlugCommitNodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRepositoriesWorkspaceRepoSlugCommitNodeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetRepositoriesWorkspaceRepoSlugCommitNode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetRepositoriesWorkspaceRepoSlugCommitNodeComments Returns the commit's comments.

This includes both global and inline comments.

The default sorting is oldest to newest and can be overridden with
the `sort` query parameter.
*/
func (a *Client) GetRepositoriesWorkspaceRepoSlugCommitNodeComments(params *GetRepositoriesWorkspaceRepoSlugCommitNodeCommentsParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesWorkspaceRepoSlugCommitNodeCommentsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepositoriesWorkspaceRepoSlugCommitNodeCommentsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRepositoriesWorkspaceRepoSlugCommitNodeComments",
		Method:             "GET",
		PathPattern:        "/repositories/{workspace}/{repo_slug}/commit/{node}/comments",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRepositoriesWorkspaceRepoSlugCommitNodeCommentsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRepositoriesWorkspaceRepoSlugCommitNodeCommentsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetRepositoriesWorkspaceRepoSlugCommitNodeComments: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetRepositoriesWorkspaceRepoSlugCommitNodeCommentsCommentID Returns the specified commit comment.
*/
func (a *Client) GetRepositoriesWorkspaceRepoSlugCommitNodeCommentsCommentID(params *GetRepositoriesWorkspaceRepoSlugCommitNodeCommentsCommentIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesWorkspaceRepoSlugCommitNodeCommentsCommentIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepositoriesWorkspaceRepoSlugCommitNodeCommentsCommentIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRepositoriesWorkspaceRepoSlugCommitNodeCommentsCommentID",
		Method:             "GET",
		PathPattern:        "/repositories/{workspace}/{repo_slug}/commit/{node}/comments/{comment_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRepositoriesWorkspaceRepoSlugCommitNodeCommentsCommentIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRepositoriesWorkspaceRepoSlugCommitNodeCommentsCommentIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetRepositoriesWorkspaceRepoSlugCommitNodeCommentsCommentID: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetRepositoriesWorkspaceRepoSlugCommits These are the repository's commits. They are paginated and returned
in reverse chronological order, similar to the output of `git log` and
`hg log`. Like these tools, the DAG can be filtered.

## GET /repositories/{workspace}/{repo_slug}/commits/

Returns all commits in the repo in topological order (newest commit
first). All branches and tags are included (similar to
`git log --all` and `hg log`).

## GET /repositories/{workspace}/{repo_slug}/commits/master

Returns all commits on rev `master` (similar to `git log master`,
`hg log master`).

## GET /repositories/{workspace}/{repo_slug}/commits/dev?exclude=master

Returns all commits on ref `dev`, except those that are reachable on
`master` (similar to `git log dev ^master`).

## GET /repositories/{workspace}/{repo_slug}/commits/?exclude=master

Returns all commits in the repo that are not on master
(similar to `git log --all ^master`).

## GET /repositories/{workspace}/{repo_slug}/commits/?include=foo&include=bar&exclude=fu&exclude=fubar

Returns all commits that are on refs `foo` or `bar`, but not on `fu` or
`fubar` (similar to `git log foo bar ^fu ^fubar`).

An optional `path` parameter can be specified that will limit the
results to commits that affect that path. `path` can either be a file
or a directory. If a directory is specified, commits are returned that
have modified any file in the directory tree rooted by `path`. It is
important to note that if the `path` parameter is specified, the commits
returned by this endpoint may no longer be a DAG, parent commits that
do not modify the path will be omitted from the response.

## GET /repositories/{workspace}/{repo_slug}/commits/?path=README.md&include=foo&include=bar&exclude=master

Returns all commits that are on refs `foo` or `bar`, but not on `master`
that changed the file README.md.

## GET /repositories/{workspace}/{repo_slug}/commits/?path=src/&include=foo&include=bar&exclude=master

Returns all commits that are on refs `foo` or `bar`, but not on `master`
that changed to a file in any file in the directory src or its children.

Because the response could include a very large number of commits, it
is paginated. Follow the 'next' link in the response to navigate to the
next page of commits. As with other paginated resources, do not
construct your own links.

When the include and exclude parameters are more than can fit in a
query string, clients can use a `x-www-form-urlencoded` POST instead.
*/
func (a *Client) GetRepositoriesWorkspaceRepoSlugCommits(params *GetRepositoriesWorkspaceRepoSlugCommitsParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepositoriesWorkspaceRepoSlugCommitsParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRepositoriesWorkspaceRepoSlugCommits",
		Method:             "GET",
		PathPattern:        "/repositories/{workspace}/{repo_slug}/commits",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRepositoriesWorkspaceRepoSlugCommitsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil
}

/*
  GetRepositoriesWorkspaceRepoSlugCommitsRevision These are the repository's commits. They are paginated and returned
in reverse chronological order, similar to the output of `git log` and
`hg log`. Like these tools, the DAG can be filtered.

## GET /repositories/{workspace}/{repo_slug}/commits/

Returns all commits in the repo in topological order (newest commit
first). All branches and tags are included (similar to
`git log --all` and `hg log`).

## GET /repositories/{workspace}/{repo_slug}/commits/master

Returns all commits on rev `master` (similar to `git log master`,
`hg log master`).

## GET /repositories/{workspace}/{repo_slug}/commits/dev?exclude=master

Returns all commits on ref `dev`, except those that are reachable on
`master` (similar to `git log dev ^master`).

## GET /repositories/{workspace}/{repo_slug}/commits/?exclude=master

Returns all commits in the repo that are not on master
(similar to `git log --all ^master`).

## GET /repositories/{workspace}/{repo_slug}/commits/?include=foo&include=bar&exclude=fu&exclude=fubar

Returns all commits that are on refs `foo` or `bar`, but not on `fu` or
`fubar` (similar to `git log foo bar ^fu ^fubar`).

An optional `path` parameter can be specified that will limit the
results to commits that affect that path. `path` can either be a file
or a directory. If a directory is specified, commits are returned that
have modified any file in the directory tree rooted by `path`. It is
important to note that if the `path` parameter is specified, the commits
returned by this endpoint may no longer be a DAG, parent commits that
do not modify the path will be omitted from the response.

## GET /repositories/{workspace}/{repo_slug}/commits/?path=README.md&include=foo&include=bar&exclude=master

Returns all commits that are on refs `foo` or `bar`, but not on `master`
that changed the file README.md.

## GET /repositories/{workspace}/{repo_slug}/commits/?path=src/&include=foo&include=bar&exclude=master

Returns all commits that are on refs `foo` or `bar`, but not on `master`
that changed to a file in any file in the directory src or its children.

Because the response could include a very large number of commits, it
is paginated. Follow the 'next' link in the response to navigate to the
next page of commits. As with other paginated resources, do not
construct your own links.

When the include and exclude parameters are more than can fit in a
query string, clients can use a `x-www-form-urlencoded` POST instead.
*/
func (a *Client) GetRepositoriesWorkspaceRepoSlugCommitsRevision(params *GetRepositoriesWorkspaceRepoSlugCommitsRevisionParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepositoriesWorkspaceRepoSlugCommitsRevisionParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRepositoriesWorkspaceRepoSlugCommitsRevision",
		Method:             "GET",
		PathPattern:        "/repositories/{workspace}/{repo_slug}/commits/{revision}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRepositoriesWorkspaceRepoSlugCommitsRevisionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil
}

/*
  GetRepositoriesWorkspaceRepoSlugDiffSpec Produces a raw, git-style diff for either a single commit (diffed
against its first parent), or a revspec of 2 commits (e.g.
`3a8b42..9ff173` where the first commit represents the source and the
second commit the destination).

In case of the latter (diffing a revspec), a 3-way diff, or merge diff,
is computed. This shows the changes introduced by the left branch
(`3a8b42` in our example) as compared againt the right branch
(`9ff173`).

This is equivalent to merging the left branch into the right branch and
then computing the diff of the merge commit against its first parent
(the right branch). This follows the same behavior as pull requests
that also show this style of 3-way, or merge diff.

While similar to patches, diffs:

* Don't have a commit header (username, commit message, etc)
* Support the optional `path=foo/bar.py` query param to filter
  the diff to just that one file diff

The raw diff is returned as-is, in whatever encoding the files in the
repository use. It is not decoded into unicode. As such, the
content-type is `text/plain`.
*/
func (a *Client) GetRepositoriesWorkspaceRepoSlugDiffSpec(params *GetRepositoriesWorkspaceRepoSlugDiffSpecParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesWorkspaceRepoSlugDiffSpecOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepositoriesWorkspaceRepoSlugDiffSpecParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRepositoriesWorkspaceRepoSlugDiffSpec",
		Method:             "GET",
		PathPattern:        "/repositories/{workspace}/{repo_slug}/diff/{spec}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRepositoriesWorkspaceRepoSlugDiffSpecReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRepositoriesWorkspaceRepoSlugDiffSpecOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetRepositoriesWorkspaceRepoSlugDiffSpec: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetRepositoriesWorkspaceRepoSlugMergeBaseRevspec Returns the best common ancestor between two commits, specified in a revspec
of 2 commits (e.g. 3a8b42..9ff173).

If more than one best common ancestor exists, only one will be returned. It is
unspecified which will be returned.
*/
func (a *Client) GetRepositoriesWorkspaceRepoSlugMergeBaseRevspec(params *GetRepositoriesWorkspaceRepoSlugMergeBaseRevspecParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesWorkspaceRepoSlugMergeBaseRevspecOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepositoriesWorkspaceRepoSlugMergeBaseRevspecParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRepositoriesWorkspaceRepoSlugMergeBaseRevspec",
		Method:             "GET",
		PathPattern:        "/repositories/{workspace}/{repo_slug}/merge-base/{revspec}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRepositoriesWorkspaceRepoSlugMergeBaseRevspecReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRepositoriesWorkspaceRepoSlugMergeBaseRevspecOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetRepositoriesWorkspaceRepoSlugMergeBaseRevspec: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetRepositoriesWorkspaceRepoSlugPatchSpec Produces a raw patch for a single commit (diffed against its first
parent), or a patch-series for a revspec of 2 commits (e.g.
`3a8b42..9ff173` where the first commit represents the source and the
second commit the destination).

In case of the latter (diffing a revspec), a patch series is returned
for the commits on the source branch (`3a8b42` and its ancestors in
our example). For Mercurial, a single patch is returned that combines
the changes of all commits on the source branch.

While similar to diffs, patches:

* Have a commit header (username, commit message, etc)
* Do not support the `path=foo/bar.py` query parameter

The raw patch is returned as-is, in whatever encoding the files in the
repository use. It is not decoded into unicode. As such, the
content-type is `text/plain`.
*/
func (a *Client) GetRepositoriesWorkspaceRepoSlugPatchSpec(params *GetRepositoriesWorkspaceRepoSlugPatchSpecParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesWorkspaceRepoSlugPatchSpecOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepositoriesWorkspaceRepoSlugPatchSpecParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRepositoriesWorkspaceRepoSlugPatchSpec",
		Method:             "GET",
		PathPattern:        "/repositories/{workspace}/{repo_slug}/patch/{spec}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRepositoriesWorkspaceRepoSlugPatchSpecReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRepositoriesWorkspaceRepoSlugPatchSpecOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetRepositoriesWorkspaceRepoSlugPatchSpec: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PostRepositoriesWorkspaceRepoSlugCommitNodeApprove Approve the specified commit as the authenticated user.

This operation is only available to users that have explicit access to
the repository. In contrast, just the fact that a repository is
publicly accessible to users does not give them the ability to approve
commits.
*/
func (a *Client) PostRepositoriesWorkspaceRepoSlugCommitNodeApprove(params *PostRepositoriesWorkspaceRepoSlugCommitNodeApproveParams, authInfo runtime.ClientAuthInfoWriter) (*PostRepositoriesWorkspaceRepoSlugCommitNodeApproveOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostRepositoriesWorkspaceRepoSlugCommitNodeApproveParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostRepositoriesWorkspaceRepoSlugCommitNodeApprove",
		Method:             "POST",
		PathPattern:        "/repositories/{workspace}/{repo_slug}/commit/{node}/approve",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostRepositoriesWorkspaceRepoSlugCommitNodeApproveReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PostRepositoriesWorkspaceRepoSlugCommitNodeApproveOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for PostRepositoriesWorkspaceRepoSlugCommitNodeApprove: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PostRepositoriesWorkspaceRepoSlugCommitNodeComments Creates new comment on the specified commit.

To post a reply to an existing comment, include the `parent.id` field:

```
$ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/db9ba1e031d07a02603eae0e559a7adc010257fc/comments/ \
  -X POST -u evzijst \
  -H 'Content-Type: application/json' \
  -d '{"content": {"raw": "One more thing!"},
       "parent": {"id": 5728901}}'
```
*/
func (a *Client) PostRepositoriesWorkspaceRepoSlugCommitNodeComments(params *PostRepositoriesWorkspaceRepoSlugCommitNodeCommentsParams, authInfo runtime.ClientAuthInfoWriter) (*PostRepositoriesWorkspaceRepoSlugCommitNodeCommentsCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostRepositoriesWorkspaceRepoSlugCommitNodeCommentsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostRepositoriesWorkspaceRepoSlugCommitNodeComments",
		Method:             "POST",
		PathPattern:        "/repositories/{workspace}/{repo_slug}/commit/{node}/comments",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostRepositoriesWorkspaceRepoSlugCommitNodeCommentsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PostRepositoriesWorkspaceRepoSlugCommitNodeCommentsCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for PostRepositoriesWorkspaceRepoSlugCommitNodeComments: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PostRepositoriesWorkspaceRepoSlugCommits Identical to `GET /repositories/{workspace}/{repo_slug}/commits`,
except that POST allows clients to place the include and exclude
parameters in the request body to avoid URL length issues.

**Note that this resource does NOT support new commit creation.**
*/
func (a *Client) PostRepositoriesWorkspaceRepoSlugCommits(params *PostRepositoriesWorkspaceRepoSlugCommitsParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostRepositoriesWorkspaceRepoSlugCommitsParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostRepositoriesWorkspaceRepoSlugCommits",
		Method:             "POST",
		PathPattern:        "/repositories/{workspace}/{repo_slug}/commits",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostRepositoriesWorkspaceRepoSlugCommitsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil
}

/*
  PostRepositoriesWorkspaceRepoSlugCommitsRevision Identical to `GET /repositories/{workspace}/{repo_slug}/commits`,
except that POST allows clients to place the include and exclude
parameters in the request body to avoid URL length issues.

**Note that this resource does NOT support new commit creation.**
*/
func (a *Client) PostRepositoriesWorkspaceRepoSlugCommitsRevision(params *PostRepositoriesWorkspaceRepoSlugCommitsRevisionParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostRepositoriesWorkspaceRepoSlugCommitsRevisionParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostRepositoriesWorkspaceRepoSlugCommitsRevision",
		Method:             "POST",
		PathPattern:        "/repositories/{workspace}/{repo_slug}/commits/{revision}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostRepositoriesWorkspaceRepoSlugCommitsRevisionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
