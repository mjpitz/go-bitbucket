// Code generated by go-swagger; DO NOT EDIT.

package branchrestrictions

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new branchrestrictions API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for branchrestrictions API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientService is the interface for Client methods
type ClientService interface {
	DeleteRepositoriesWorkspaceRepoSlugBranchRestrictionsID(params *DeleteRepositoriesWorkspaceRepoSlugBranchRestrictionsIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteRepositoriesWorkspaceRepoSlugBranchRestrictionsIDNoContent, error)

	GetRepositoriesWorkspaceRepoSlugBranchRestrictions(params *GetRepositoriesWorkspaceRepoSlugBranchRestrictionsParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesWorkspaceRepoSlugBranchRestrictionsOK, error)

	GetRepositoriesWorkspaceRepoSlugBranchRestrictionsID(params *GetRepositoriesWorkspaceRepoSlugBranchRestrictionsIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesWorkspaceRepoSlugBranchRestrictionsIDOK, error)

	PostRepositoriesWorkspaceRepoSlugBranchRestrictions(params *PostRepositoriesWorkspaceRepoSlugBranchRestrictionsParams, authInfo runtime.ClientAuthInfoWriter) (*PostRepositoriesWorkspaceRepoSlugBranchRestrictionsCreated, error)

	PutRepositoriesWorkspaceRepoSlugBranchRestrictionsID(params *PutRepositoriesWorkspaceRepoSlugBranchRestrictionsIDParams, authInfo runtime.ClientAuthInfoWriter) (*PutRepositoriesWorkspaceRepoSlugBranchRestrictionsIDOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  DeleteRepositoriesWorkspaceRepoSlugBranchRestrictionsID Deletes an existing branch restriction rule.
*/
func (a *Client) DeleteRepositoriesWorkspaceRepoSlugBranchRestrictionsID(params *DeleteRepositoriesWorkspaceRepoSlugBranchRestrictionsIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteRepositoriesWorkspaceRepoSlugBranchRestrictionsIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRepositoriesWorkspaceRepoSlugBranchRestrictionsIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteRepositoriesWorkspaceRepoSlugBranchRestrictionsID",
		Method:             "DELETE",
		PathPattern:        "/repositories/{workspace}/{repo_slug}/branch-restrictions/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteRepositoriesWorkspaceRepoSlugBranchRestrictionsIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteRepositoriesWorkspaceRepoSlugBranchRestrictionsIDNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for DeleteRepositoriesWorkspaceRepoSlugBranchRestrictionsID: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetRepositoriesWorkspaceRepoSlugBranchRestrictions Returns a paginated list of all branch restrictions on the
repository.
*/
func (a *Client) GetRepositoriesWorkspaceRepoSlugBranchRestrictions(params *GetRepositoriesWorkspaceRepoSlugBranchRestrictionsParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesWorkspaceRepoSlugBranchRestrictionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepositoriesWorkspaceRepoSlugBranchRestrictionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRepositoriesWorkspaceRepoSlugBranchRestrictions",
		Method:             "GET",
		PathPattern:        "/repositories/{workspace}/{repo_slug}/branch-restrictions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRepositoriesWorkspaceRepoSlugBranchRestrictionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRepositoriesWorkspaceRepoSlugBranchRestrictionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetRepositoriesWorkspaceRepoSlugBranchRestrictions: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetRepositoriesWorkspaceRepoSlugBranchRestrictionsID Returns a specific branch restriction rule.
*/
func (a *Client) GetRepositoriesWorkspaceRepoSlugBranchRestrictionsID(params *GetRepositoriesWorkspaceRepoSlugBranchRestrictionsIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesWorkspaceRepoSlugBranchRestrictionsIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepositoriesWorkspaceRepoSlugBranchRestrictionsIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRepositoriesWorkspaceRepoSlugBranchRestrictionsID",
		Method:             "GET",
		PathPattern:        "/repositories/{workspace}/{repo_slug}/branch-restrictions/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRepositoriesWorkspaceRepoSlugBranchRestrictionsIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRepositoriesWorkspaceRepoSlugBranchRestrictionsIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetRepositoriesWorkspaceRepoSlugBranchRestrictionsID: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PostRepositoriesWorkspaceRepoSlugBranchRestrictions Creates a new branch restriction rule for a repository.

`kind` describes what will be restricted. Allowed values include:
`push`, `force`, `delete` and `restrict_merges`.

Different kinds of branch restrictions have different requirements:

* `push` and `restrict_merges` require `users` and `groups` to be
  specified. Empty lists are allowed, in which case permission is
  denied for everybody.
* `force` can not be specified in a Mercurial repository.

The restriction applies to all branches that match. There are
two ways to match a branch. It is configured in `branch_match_kind`:

1. `glob`: Matches a branch against the `pattern`. A `'*'` in
   `pattern` will expand to match zero or more characters, and every
   other character matches itself. For example, `'foo*'` will match
   `'foo'` and `'foobar'`, but not `'barfoo'`. `'*'` will match all
   branches.
2. `branching_model`: Matches a branch against the repository's
   branching model. The `branch_type` controls the type of branch
   to match. Allowed values include: `production`, `development`,
   `bugfix`, `release`, `feature` and `hotfix`.

The combination of `kind` and match must be unique. This means that
two `glob` restrictions in a repository cannot have the same `kind` and
`pattern`. Additionally, two `branching_model` restrictions in a
repository cannot have the same `kind` and `branch_type`.

`users` and `groups` are lists of users and groups that are except from
the restriction. They can only be configured in `push` and
`restrict_merges` restrictions. The `push` restriction stops a user
pushing to matching branches unless that user is in `users` or is a
member of a group in `groups`. The `restrict_merges` stops a user
merging pull requests to matching branches unless that user is in
`users` or is a member of a group in `groups`. Adding new users or
groups to an existing restriction should be done via `PUT`.

Note that branch restrictions with overlapping matchers is allowed,
but the resulting behavior may be surprising.
*/
func (a *Client) PostRepositoriesWorkspaceRepoSlugBranchRestrictions(params *PostRepositoriesWorkspaceRepoSlugBranchRestrictionsParams, authInfo runtime.ClientAuthInfoWriter) (*PostRepositoriesWorkspaceRepoSlugBranchRestrictionsCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostRepositoriesWorkspaceRepoSlugBranchRestrictionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostRepositoriesWorkspaceRepoSlugBranchRestrictions",
		Method:             "POST",
		PathPattern:        "/repositories/{workspace}/{repo_slug}/branch-restrictions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostRepositoriesWorkspaceRepoSlugBranchRestrictionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PostRepositoriesWorkspaceRepoSlugBranchRestrictionsCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for PostRepositoriesWorkspaceRepoSlugBranchRestrictions: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PutRepositoriesWorkspaceRepoSlugBranchRestrictionsID Updates an existing branch restriction rule.

Fields not present in the request body are ignored.

See [`POST`](../branch-restrictions#post) for details.
*/
func (a *Client) PutRepositoriesWorkspaceRepoSlugBranchRestrictionsID(params *PutRepositoriesWorkspaceRepoSlugBranchRestrictionsIDParams, authInfo runtime.ClientAuthInfoWriter) (*PutRepositoriesWorkspaceRepoSlugBranchRestrictionsIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutRepositoriesWorkspaceRepoSlugBranchRestrictionsIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PutRepositoriesWorkspaceRepoSlugBranchRestrictionsID",
		Method:             "PUT",
		PathPattern:        "/repositories/{workspace}/{repo_slug}/branch-restrictions/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutRepositoriesWorkspaceRepoSlugBranchRestrictionsIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PutRepositoriesWorkspaceRepoSlugBranchRestrictionsIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for PutRepositoriesWorkspaceRepoSlugBranchRestrictionsID: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
